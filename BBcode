-------------------------------------------------------------------------------------------------------------------------------------------
Intro. Введение
-------------------------------------------------------------------------------------------------------------------------------------------
The guide is written in Russian. Please use [url=https://translate.google.com/]Google Translate[/url] for translation into other languages. You can also read the [url=https://steamcommunity.com/sharedfiles/filedetails/?id=685206874]Easy Automation 2.0 manual[/url], see examples and demo ships discussions topics to understand the basic principles of developing automation scripts. I am also ready to try in English to answer your questions related to the use of new commands in the discussions for this quide. 

[h3]Demo ships[/h3]
[url=steamcommunity.com/sharedfiles/filedetails/?id=2688925369]SE Mothership[/url] — the main demo ship on which most of the Easy Play command are implemented 
[url=https://steamcommunity.com/sharedfiles/filedetails/?id=2688920956]SE Escape Pod[/url] — auxiliary demo ship to demonstrate antenna interaction
[url=https://steamcommunity.com/sharedfiles/filedetails/?id=2710388327]SE Sputnic[/url] — demonstration of real gameplay and cross-script communication
[url=https://steamcommunity.com/sharedfiles/filedetails/?id=2725165752]SN Carrier[/url] — ship life support control by timer (autodoor, airlock, online monitoring etc.)
[hr][/hr]
[b]Easy Play[/b] — это форк популярного скрипта [url=https://steamcommunity.com/sharedfiles/filedetails/?id=694296356]Easy Automatition 2.0[/url] который, к моменту написания данного руководства, являлся самым простым из всех существующих в Workshop скриптов автоматизации. 

Код оригинального скрипта был полностью переписан и дополнен недостающим для меня функционалом, но общая концепция и основной синтаксис не изменились. Поэтому если вы раньше использовали Easy Automatition, то работа с Easy Play не должна вызвать проблем.

Для тех, кто сталкивается с автоматизацией впервые, скажу, что Easy Play позволяет реализовывать достаточно сложные сценарии типа запуска ракет, возврата к носителю по сигналу антенны, вывода инвентаря корабля на любой экран в нужном вам формате и т.п. без необходимости программирования скриптов на языке C#. 

По сути, это альтернатива автоматизации на таймерах, но с возможностью выборочного анализа состояния игровых блоков и доступом к расширенному управлению ими. Например, с помощью Easy Play можно управлять гасителями, чего на таймерах запрограммировать нельзя.

[b]От оригинала Easy Play отличает:[/b]
[list]
[*] отсутствие отдельной LCD панели, в CustomData которой размещается код автоматизации

[*] более свободный синтаксис логики [b][i]if/else[/i][/b] ,не требующий оформления фигурных скобок с новой строки, а так же наличие не бинарной логики

[*] возможность использования динамических переменных в любом месте выражения

[*] возможность переопределения глобальных переменных в коде любого сценария

[*] сокращенный синтаксис без учета регистра написания большинства свойств и действий 

[*] наличие детальной консольной отладки с выводом ошибок компиляции и выполнения

[*] устойчивость к краху программного блока из-за опечаток и ошибок оформления кода

[*] простая локализации на любой язык (не уверен насчет восточных и иероглифических)

[*] возможность работы с гридами и сабгридами

[*] обработка текстовых данных, в т.ч. CustomData и полей редактирования любых экранов

[*] расширенные функциональные возможности, включая обмен данными через антенну, Raycast-лидар и инвентаризацию.
[/list]

[h3]Демонстрационные корабли[/h3]
[url=https://steamcommunity.com/sharedfiles/filedetails/?id=2688925369]SE Mothership[/url] — основной корабль на котором представлено большинство команд Easy Play 
[url=https://steamcommunity.com/sharedfiles/filedetails/?id=2688920956]SE Escape Pod[/url] — вспомогательный корабль, для демонстрации взаимодействия через антенну
[url=https://steamcommunity.com/sharedfiles/filedetails/?id=2710388327]SE Sputnic[/url] — реальный игровой процесс и взаимодействие с другими скриптами
[url=https://steamcommunity.com/sharedfiles/filedetails/?id=2725165752]SN Carrier[/url] — управление системой жизнеобеспечения (двери, шлюзы, мониторинг и т.п.)

-------------------------------------------------------------------------------------------------------------------------------------------
Термины и определения
-------------------------------------------------------------------------------------------------------------------------------------------
[b]Автоматизация[/b] — код, который находится в поле "[u]Свои данные[/u]" (далее CustomData) программного блока (далее ПБ) Easy Play 

[b]@-блок[/b] — именованная последовательность команд, заключенных в фигурные скобки, размещенная внутри кода автоматизации с помощью которой можно управлять состоянием игровых функциональных блоков — выдвигать поршни, открывать и закрывать двери и т.п. В коде автоматизации может быть любое количество @-блок (сценариев), которые можно вызывать через панель управления. Ниже представлено два таких сценария:
[code]
* вывод свойств и действий блока
@show {
Show \1
}
* переименование блоков
@rename {
Rename \1 to \2
}
[/code]

[b]Блок переменных[/b] — специальный @-блок имя которого должно начинаться с [b]var[/b] (без учета регистра), внутри которого определяются глобальные переменные используемые внутри сценариев автоматизации.
[code]
@Vars {
pos = Position of MyPiston
}
[/code]

[b]Комментарий[/b] — любая строка внутри автоматизации, начинающаяся с символа звездочка "*", комментарии игнорируются при обработке, поэтому при оформлении многострочных математических выражений, использующих для умножения "*" или вывода строк, включающих перенос на новую строку, следует избегать появления "*" в начале новой строки. 

[b]Консоль[/b] — данные поля "[u]Редактировать[/u]" основного экрана ПБ Easy Play, куда в случае установленного режима отладки выводится ход выполнения вызванного через строку параметров @-блока

[b]Локализация[/b] — данные поля "[u]Редактировать[/u]" экрана клавиатуры ПБ Easy Play, где размещаются секции перевода системных сообщений, состояний блоков и названий игровых компонентов (руды, слитки и т.п.), если это поле пустое то используется английский язык

[b]Панель управления[/b] - игровая системная панель, вызываемая на экран клавишей [i][b]K[/b][/i] которая дает доступ к списку функциональных блоков и управлению их свойствами и действиями (см. рисунок ниже).

[b]Контроллер[/b] — кокпит, пилотское кресло, станция управления, блок дистанционного управления, т.е. блок, с помощью которого можно управлять движением корабля через клавиатуру или мышь. В большинстве случаев контроллер необходим для автоматизации, т.к. с его помощью можно получать доступ к свойствам, которые помогают при автоматизации например скорость, координаты и т.п.

[b]Область Echo[/b] — область для вывода дополнительной системной информации о блоке, которая находится в правом нижнем углу панели управления. Easy Play также может использовать эту область для вывода своих сообщений по команде Echo.
[quote][previewimg=25668801;sizeFull,inline;ep_01.jpg][/previewimg][/quote]

-------------------------------------------------------------------------------------------------------------------------------------------
@-блок автоматизации
-------------------------------------------------------------------------------------------------------------------------------------------
[b]@-блок[/b] или сценарий автоматизации всегда оформляется с новой строки, которая должна заканчиваться открывающий фигурной скобкой "{" и которой должна соответствовать закрывающая фигурная скобка "}". 

В имени @-блока допускается использование прописных и строчных английских букв, цифр и символов "-" (минус), "_" (подчеркивание). Например:
[code]
@move_piston {
UpperLimit of MyPiston = 7
Reverse MyPiston  
}  
[/code]
Выполнить сценарий можно указав имя @-блока в поле "[u]Аргумент[/u]" ПБ Easy Play с учетом написания и нажав "[u]Выполнить[/u]". Дополнительно в круглых скобках "()", через запятую ","  можно указать параметры, к которым можно обратиться внутри @-блока по порядковому номеру.

Сценарий будет выполняться построчно, с учетом логики [b][i]if/else[/i][/b], до тех пор, пока не будет достигнута конечная "}" скобка или в коде сценария не встретится команда [b]Stop[/b] или [b]End[/b].
[quote][previewimg=25817710;sizeFull,inline;ep_08.jpg][/previewimg][/quote]
[h2]Запуск @-блока по ссылке[/h2]
Один сценарий внутри своего кода может вызвать выполнение другого сценария. Сделать это можно по ссылке с использованием символа "@" за которым следует имя того @-блока, который нужно выполнить. 

Например следующая автоматизация вызывает световое и текстовое оповещение если хотя бы одна турель Гатлинга обнаруживает цель.
[code]
@has_target {
* если турель имеет цель
If Status of Gatling = Target {
* активируем сценарий тревоги  
  @alert(Нападение противника)
} else {
* если нет, то сценарий отбой тревоги  
  Exec @silent
}
}
@alert {
* установить режим мерцания ламп, объедиенных в группу Alert light
Blink Interval of (Alert light) = 0.5
* вывести на LCD-панель надпись, переданную в сценарий первым параметром
Write to LCD Alert = \1  
}
@silent {
* отменить мерцание
Blink Interval of (Alert light) = 0
* очистить LCD
Write to LCD Alert = ""
}
[/code]

В отличии от Easy Automatition, Easy Play может вызывать другой @-блок по ссылке с параметром, который установит локальную переменную так, как если бы обращение к нему было из поля "[u]Аргумент[/u]" программного блока. Это позволяет использовать один и того же сценарий в разных случаях. 

Например, тревога на корабле может быть объявлена не только при нападении, но и при разгерметизации. В этом случае можно повторно использовать сценарий [i]@alert[/i], а в качестве параметра передать ему "Разгерметизация" вместо "Нападение противника". 

Вызвать @-блок по ссылке можно в по полной форме, указав перед именем сценария ключевое слово [b]Exec[/b]. Подобное оформление используется при обмене данных через антенну, чтобы избежать ошибок компиляции.

[b]Hint:[/b] если надо узнать был ли передан аргумент или нет, используйте следующий код:
[code]
if \1 ? \ {
Echo = "Вызов без аргумента"
}
[/code]

-------------------------------------------------------------------------------------------------------------------------------------------
Свойства и действия
-------------------------------------------------------------------------------------------------------------------------------------------
[quote]
[b]Внимание! Easy Play работает только с теми блоками, владельцем которых вы являетесь. [/b]
[/quote]
Каждый игровой блок имеет набор свойств и действий которые в игре вы можете установить либо напрямую через панель управления, либо через цифровую клавиатуру контроллера вынося на нее иконки блоков и задавая действия, которые с ней связаны. 

Например для поршня можно вывести свойство "Верхний предел" и действие "Реверс". Тоже самое можно установить через панель управления при помощи соответствующего ползунка и кнопки. Это долго, гораздо проще обратиться к небольшому сценарию автоматизации, который сделает тоже самое без вызовов системных панелей:
[code]
@move_piston {
* установить свойство "Верхний предел"
UpperLimit of MyPiston = 7
* выполненить действия "Реверс"
Reverse MyPiston
}
[/code]
Собственно в этом и заключается суть автоматизации — вместо того, чтобы искать в панели управления нужный вам блок и затем выносить на цифровую панель контроллера несколько связанных с ним иконок, достаточно в CustomData ПБ Easy Play написать сценарий в несколько строк и вынести на цифровую панель выполнение программного блока с заданным параметром, в данном случае — "move_piston". 

Обращение к свойству блока производится с указанием ключевого слова [b]of[/b]. Действие выполняется без указания ключевых слов — только команда и выборка блоков:
[code]
* установка свойства перехват управления для трастеров
Override of Ion Thruster = 100%
* выполнение команды включить перехват управления гироскопами
Override Gyroscope
[/code]

[h2]Команда Show[/h2]
Все доступные свойства и действия, связанные с конкретным типом блока — вентиляцией, сборщиком, турелью и т.п. можно вывести на консоль одной внутренней командой:

 [b]Show[/b][type] [b]Имя_Блока[/b], где в [] квадратных скобках можно указать одно из следующих значений: [i]action[/i] — вывести только действия блока, [i]info[/i] — вывести только дополнительную информацию и [i]property[/i] — вывести только свойства блока. Все значения можно сократить до одной буквы: [i]a[/i], [i]i[/i], [i]p[/i]

Без [] будет выведена вся доступная информация о блоке. Следующий сценарий выведет на экран всю информацию о блоке вентиляции имя которого начинается с Airvent:
[code]
@info {
Show Airvent
}
[/code]
После выполнения этого сценария на экран консоли и в область Echo панели управления будет выведенная следующая информация (c вер. 1.33 свойства выводятся не через двоеточие, а через знак равенства):

[previewimg=25669275;sizeFull,inline;ep_02.jpg][/previewimg]
.
Есть разница при выводе свойств блока в общем потоке, когда команда [b]Show[/b] вызывается без [] квадратных скобок, и отдельно с указанием [b]Show[property][/b]. В последнем случае будет выведен не тип присваемого значения: True/False, Number или Color, а само значение. Это удобно для сохранения текущих установок и последующего их восстановления командой [b]Set[/b].

-------------------------------------------------------------------------------------------------------------------------------------------
Типы данных
-------------------------------------------------------------------------------------------------------------------------------------------
Есть 5 типов данных, которые определяются представлением переменной:

[b]Логический тип[/b] — может иметь два значения True или False

[b]Число (Number)[/b]  — положительное или отрицательное число с десятичной точкой, граничные значения которого определяются игровыми свойствами блока. Например, верхний предел для поршня на большой сетке может быть числом от 0 до 10.

[b]Цвет (Color)[/b] — RGB-представление триады цветов с разделителем ":", например 0:0:255 (синий цвет), где каждое значение есть целое положительное число от 0 до 255. В панели управления оно устанавливается при помощи трех ползунков или вводом значения для каждого цвета с использованием <Ctrl+ЛКМ> (левая кнопка мыши).

[b]GPS-координаты [/b]— триада координат X:Y:Z с разделителем ":", например "[i]-62664.81:-80178.37:-27915.08[/i]" где каждое значение может быть положительным или отрицательным числом с десятичной точкой. 

Полный формат GPS-координат состоит из 6 частей и его можно увидеть в системном меню GPS, если скопировать любую GPS-метку в буфер обмена и затем вставить через <Ctrl+V> в любое текстовое поле, например: [i]GPS:Base:-62664.81:-80178.37:-27915.08:#[/i], где 

[i]GPS[/i] = обязательный префикс из трех английских прописных букв
[i]Base[/i] = произвольное название точки координат
[i]-62664.81[/i] = координаты по оси Х, любое положительное или отрицательное цисло с "." 
[i]-80178.37[/i] = тоже по оси Y
[i]-27915.08[/i] = тоже по оси Z
[i]#[/i] = RGBA-представление цвета на экране (само значение можно опустить)

Обмен координатами через антенну и размещение их в списке точек назначения автопилота производится в полном формате.

[b]Строка (String)[/b] — если значение отличается от выше перечисленных представлений, то оно считается строчным. Обычно для указания этого типа используются двойные кавычки ", но они необязательны, кроме представления многострочных значений или трансляции свойств блоков при выводе на экран (см. раздел "Запись и чтение LCD")  и представления пустого значения. Ниже представлена инициализация и вывод на консоль трех строчных переменных
[code]
@vars {
name = Ирокез
type = "Ударный носитель"
value = ""
}
@view {
Console = "\name \N \type \value"
}
[/code]

Тип данных вы можете увидеть в свойствах блока. Например, при выводе свойств поршня по команде [b]Show[/b], они, в том числе, будут представлены следующими значениями:
[code]
* логический тип
ShareInertiaTensor: [b]True/False[/b]
* число с десятичной точкой
UpperLimit: [b]Number[/b]
[/code]
Любая переменная в @-блоке может переопределена и представлена любым типом данных, который, в свою очередь, может являться состоянием игрового блока, а так же условным или математическим выражением.

-------------------------------------------------------------------------------------------------------------------------------------------
Типы переменных
-------------------------------------------------------------------------------------------------------------------------------------------
Переменные Easy Play бываю двух видов:

[b]глобальные[/b], которые определяются в специальном @-блоке, начинающегося с [i]@var[/i] и доступные для любого сценария внутри автоматизации. Блок [i]@var[/i] должен быть [b]первым блоком[/b] в поле CustomData, если предполагается использование глобальных переменных

[b]локальные[/b] (динамические) которые создаются при запуске сценария из строки аргументов ПБ с перечислением через "," с использованием "()" (круглых скобок) и которые доступны только для того @-блока для которого они вызваны

[h2]Глобальные переменные[/h2]
Обращение по имени. Имя переменной должно состоять из больших и маленьких английских букв, цифр и символов "-_". Вообще-то можно использовать и другие символы, в т.ч. русские, но для гарантии правильной обработки лучше придерживаться указанного выше правила. 

Имена глобальных переменных не должны начинаться с цифр и не должны совпадать с зарезервированными системными словами типа [b]if[/b], [b]on[/b], [b]at[/b] и т.п. Полное имя переменной так же [b]не должно[/b] быть началом имени другой переменной. Например:
[code]
@vars {
* d - неверное имя переменной, так как с нее начинается имя
* другой переменной - dmin. Используйте другое, например d1
d = 0
dmin = 100
}
[/code]

В таких случаях будет выведено сообщение об ошибке, а сценарий не будет выполняться пока вы не измените имя переменной.

Инициализация любых глобальных переменных в блоке [i]@var[/i] и наличие пробелов слева и справа от знака "=" [b]обязательно[/b] иначе  будет выведено сообщение об ошибке:
[code]
@vars {
ship = ""
color = 100:0:255
gps = "GPS:Base:-62664.81:-80178.37:-27915.08:#"
* вызовет ошибку из-за отсутствия пробела между знаком = и 0
distance =0
}
[/code]

Обращаться к переменным можно по имени внутри любого @-блока указав перед ним "\" (обратную косую черту). При установке нового значения можно использовать сокращенную или полную форму записи [b]Value of[/b]:
[code]
@test {
\ship = Grid Name of MyShip
Value of color = "0:0:200"
FontColor of LCD Info = \color
Write to LCD Info = "Корабль: \ship" 
WriteLine to LCD Info = "База: \gps"
}
[/code]

Для инициализации в блоке [i]@var[/i] можно использовать любые значения, в том числе пустые, с указанием справа от знака "=" (равенства), пустой строки "", а так же состояния любых блоков, условные Cond() или математические Math() выражения, но не ссылки на другие переменные
[code]
@vars {
x = 5
* это неправильная инициализация
y = math(Position of MyPiston + \x)
}
[/code]

Использование двойных кавычек при инициализации или установке значений переменных отличных от числовых или логических True/False, не обязательно, кроме оговоренных случаев, но желательно, если вы хотите быть уверенным, что Easy Play воспримет значение так, как вы его задали. К тому же это будет смотреться более наглядно в блоке CustomData и просто облегчит отладку.

[h2]Локальные (динамические) переменные[/h2]
Инициализируются при вызове сценария через поле "Аргумент" ПБ Easy Play. Например @-блок, позволяющий увидеть все доступные свойства и действия игрового блока, вызывается набором в панели управления в поле "[u]Аргумент[/u]" вызова [i]info(Airvent, Справка)[/i]  и последующего нажатия "[u]Выполнить[/u]". Здесь через "," (запятую) инициализируются две переменных с именами 1 и 2

Обращение к локальным переменным внутри @-блока так же как и в случае с глобальными переменными, осуществляется с помощью "\" указанного перед именем. В качестве имени переменной служит ее позиция при вызове:  
[code]
@info {
* вывод заголовка "Справка", указанного во второй переменной, в область Echo
Echo = "\2\N"
* вывести на консоль свойства и действия блока с именем Airvent, указанного в первой переменной
Show \1
}
[/code]
Такие переменные доступны только в том блоке, для которого они иницализированы. Любой сценарий, если потребуется, может быть вызван с разным количеством и значением переменных и их имена будут совпадать, но не будут перекрываться.

[b]Hint:[/b] если надо узнать был ли передан аргумент или нет, используйте следующий код:
[code]
if \1 ? \ {
Echo = "Вызов без аргумента"
}
[/code]

[h2]Использование переменных[/h2]
В основном переменные используются для хранения состояний блоков и установки этих состояний. Все дело в том, что в одной строке нельзя установить значение одного свойства блока на основании другого. Например, если GPS-координата хранится в CustomData камеры, то нельзя прямо использовать это:
[code]
* так не правильно
Fly to Data of Camera Lidar at 30
UpperLimit of Piston 1 = UpperLimit of Piston 2
* надо так
\x = Data of Camera Lidar
Fly to \x at 30
\x = UpperLimit of Piston 2
UpperLimit of Piston 1 = \x
[/code]
Такое представление унаследовано от Easy Automatition и помогает упорядочить код.

-------------------------------------------------------------------------------------------------------------------------------------------
Значения переменных
-------------------------------------------------------------------------------------------------------------------------------------------
Присвоение  значения переменной в Easy Play отличается от принятого в обычном программировании. В любой момент времени в переменной храниться не вычисленное на момент инициализации значение, а [u]его представление[/u], которое будет вычислено только в момент обращения:
[code]
@variables {
* у переменной нет значения позиции поршня на момент инициализации
pos = Position of MyPiston  
}
@test {
* обращение к переменной выведет текущую позицию поршня, например 1.5
Echo = "Позиция поршня: \pos"
}
[/code]

Такой подход обеспечивает возможность гибкого управления состоянием отдельных блоков, но бывает накладным для групповых операций, например, при инвентаризации всего корабля. В этом случае полезно знать последнее вычисленное значение, чтобы при каждом обращении к представлению переменной не проводить повторную инвентаризацию.
[code]
@vars {
x = 0
* количество льда в инвентаре О2/Н2 генераторов
iceg = math(int(InvX Ice of O2\H2 Generator / 1000))
}
@ice
* фиксируем в переменной x количество льда в О2/Н2 генераторах
\x = \iceg
if Value of x > 0 {
   if StatusX of Oxygen Tank on MyGrid < 50 {
      OnOff_On O2\H2 Generator
   }
} else {
  OnOff_Off O2\H2 Generator
}
Echo = "Осталось \x тонн льда"
[/code]
Если вместо [i]x[/i], анализировать по [b]If[/b] и выводить по [b]Echo[/b] значение переменной [i]iceg[/i], то EasyPlay дважды обратился к ее представлению и выполнит инвентаризацию, но фиксация значения через другую перемененную, позволит сделать это только один раз.

[h3]Фиксация значение свойств[/h3]
Начиная с версии 1.32 EasyPlay позволяет фиксировать значение свойств блоков в переменных без использования дополнительной переменной. Этот способ называется [u]трансляцией[/u] и используется также командами [b]Write[/b] и [b]Data[/b]
[code]
@vars {
pos = Position of MyPiston
fix = "{Position of MyPiston}"
}
@test {
Extend MyPiston
Delay 1000
* выведет текущую позицию поршня = 1.01
Echo = \pos
* выведет стартовую позицию поршня = 0
Echo = \fix
[/code]
Такая фиксация применима к любым свойствам блоков но не к вычисляемым значениям по [b]math()[/b] или [b]cond()[/b], как показано в примере со льдом.

[h3]Конкатенация строк [/h3]
Трансляцию можно использовать если требуется создать строку, состоящую из выборки токенов или значений нескольких свойств, чтобы затем проанализировать или использовать ее.
[code]
* эта команда поместит расширенные координаты объекта в Custom Data камеры
Scan of Camera at 15000
* конкатенация токенов для формирования координат в формате GPS для автопилота
\gps = "GPS:{Token[3] of Camera}:{Token[8] of Camera}:{Token[9] of Camera}:{Token[10] of Camera}:#"
* устанавливаем точку назначения для автопилота
Fly to \gps at 100
[/code]
Трюк с альтернативой [b]cond()[/b] при анализе свойств:
[code]
\x = cond(OnOff of AirVent = False & OnOff of Door = False : 0 : 1)
if \x = 0 {
  Write to LCD = "Проход закрыт"
}
* так короче и быстрее с точки зрения выполнения сценария
\x = "{OnOff of AirVent} {OnOff of Door}"
if \x !? True {
  Write to LCD = "Проход закрыт"
}
[/code]

[h3]Псевдомассивы[/h3]
В версии 1.32 появилась возможность трансляции составных имен переменных, которая позволяет создать нечто похожее на массивы значений переменных. Это достигается путем использования команды [b]Value[/b] в правой части операции присвоения значения переменной. 

Представленный ниже код выведет в область эха значения трех переменных arr1, arr2 и arr3: Blue, Green и Red соответственно:
[code]
@vars {
arr1 = "Blue"
arr2 = "Green"
arr3 = "Yellow"
x = 0
y = 0
}
* обход псевдомассива из 3-х значений
@arr {
\y = math(\y + 1)
if \y < 4 {
* составное имя переменной
   \x = "arr\y"
* трансляция полученного значения
   \x = Value of x
   Echo = \x
  @arr
}
}
[/code]

-------------------------------------------------------------------------------------------------------------------------------------------
Сокращения и регистр
-------------------------------------------------------------------------------------------------------------------------------------------
Easy Play поддерживает сокращения при обращении к свойствам или действиям если такое сокращение можно однозначно трактовать. Например, чтобы отключить гасители корабля, нужно выполнить действие "[u]DampenersOverride[/u]" для любого контроллера грида. Это слишком сложно запомнить, поэтому обращение можно сократить до "[u]damp[/u]", поскольку никаких других действий, связанных с контроллером и начинающихся с этих четырех букв нет.

В случае с вентиляцией такое сокращенное обращение к действию, связанному с включением разгерметизации, не пройдет. Если вы посмотрите на список действий блока Airvent, то увидите там три почти одинаковых названия:

[i]Depressurize[/i] — переключает разгерметизацию из одного положения в другое
[i]Depressurize_On[/i] — включает разгерметизацию
[i]Depressurize_Off[/i] — выключает разгерметизацию

Так что если обратиться к действию сокращенно, например "[u]depress Airvent[/u]", то вместо включения вы переключите ее состояние из одного в другое, что может совпасть в моменте с вашими намерениями, а может и не совпасть. Поэтому для включения разгерметизации нужно использовать полную запись "[u]Depressurize_On Airvent[/u]".

Регистр текста, т.е. какими именно буквами — большими или маленькими написана команда, так же не имеет значения. Такой способ называется [b]регистронезависимым[/b] и если отдельно не оговорено, то все что вы пишите в своих @-блоках можно оформлять с учетом этого правила.

Для удобства некоторые системные команды так же имеют сокращения:

[i]\var_name[/i] вместо [i]Value of var_name[/i] — обращение к переменной внутри @-блока
[i]Echo[/i] вместо [i]Write to Echo[/i] — вывод информации в область Echo
[i]Console[/i] вместо [i]Write to Console[/i] — вывод информации на консоль

[h2]Сокращение значений переменных[/h2]
При сравнении и установке значений переменных допускается использование префиксов сокращений "k" — кило и "m"  — мега, умножающие предшествующее им числовое значение на 1000 и 100000 соответственно.
[code]
\thrust = 10.5 kN
\power = 1.3 MW
\volume = "1.5 kL"
Echo = "Тяга: \thrust \N Мощность: \power \N Объем: \volume"
if MaxImpulseAxis of Piston Escape > 100 kN {
Echo = "Превышен макс. импульс по оси поршня"
}
[/code] 
Этот сценарий выведет в область Echo следующее:
[quote][previewicon=25710235;sizeOriginal,inline;ep_06.jpg][/previewicon][/quote]
Чтобы избежать трансляции нужно заключить присваемое значение в двойные кавычки.

-------------------------------------------------------------------------------------------------------------------------------------------
Выборка блоков и гриды
-------------------------------------------------------------------------------------------------------------------------------------------
Любое действие или установка значения свойства связаны с выборкой одного или нескольких блоков по имени, которое включает указанные символы. 

Например, если на корабле есть два десятка гироскопов, с именами [i]Gyroscope 1, Gyroscope 2 ... Gyroscope 10, Gyroscope 11 ... Gyroscope 20[/i], то действие "[u]Override Gyroscope[/u]" переключит перехват управления для всех гироскопов, а действие "[u]Override Gyroscope 1[/u]", только для 10-и:[i] Gyroscope 1, Gyroscope 10, ... Gyroscope 19.[/i]

Выборка зависит от написания имени блока, т.е. действие "[u]Override gyroscope[/u]" не вызовет перехвата управления ни одним гироскопом, т.к. их имена начинаются с большой буквы "G".

Выборку можно уточнить, указав перед началом имени специальный символ:

[b]#[/b] — имя блока начинается точно с указанной последовательности, например "[u]Override #Gyro[/u]" вызовет перехват управления всеми гироскопами, если их имя начинается с [i]Gyro[/i].

[b]![/b] — имя блока в точно соответствует указанному, например "[u]Override !Gyroscope 1[/u]" перехват будет выполнен только для одного гироскопа с именем [i]Gyroscope 1[/i]

[b]?[/b] — имя блока содержит целые слова, начинающиеся с указанных слов вне зависимости от их написания. Например, "[u]Override ?gyro turn[/u]" вызовет перехват управления всеми гироскопами в имени которых есть слова, начинающиеся на "gyro" и "turn", таких как [i]Gyroscope 01 Retro Turn[/i], [i]Gyro Turn Left[/i] и т.п.

В качестве имени блока можно так же [b]использовать переменную[/b], это позволит избежать опечаток в имени блока в коде сценария и проще организовать настройку:
[code]
@var {
camera = Camera Lidar
}
@test {
Data of \camera = ""
}
[/code]

[quote]
При формировании имен блоков, которые будут участвовать в автоматизации, желательно учитывать способы обращения к ним по именам, чтобы лишние блоки не попадали в выборку. 
[/quote]
Если в выборку попадут блоки, которые не относятся к заданному действию, то скорее всего
ничего не произойдет. Большинство свойств и действий уникальны для разных типов блоков, 
однако кнопка вкл./выкл. (действие [b]OnOff[/b]) есть почти у всех блоков. Поэтому при выключении батарей "[u]OnOff_Off Battery[/u]" можно случайно отключить и дверь, ведущую в аккумуляторный отсек, если в ее названии встречается "Battery", типа [i]Door in Battery Bay[/i].

[h2]Выборка группы блоков[/h2]
Чтобы быть уверенным наверняка, что в выборку попадают нужные вам блоки, можно через панель управления объединить их в группу и использовать ее имя для установки свойства или выполнения действия. Имя группы в этом случае всегда указывается точно и ограничивается круглыми скобками:
 [code]Override (Gyroscopes)[/code]
В именах групп лучше также не использовать разделители типа ",*-+/(){}" это может ограничить использование групп например в качестве локальных переменных при вызове @-блока с параметрами, указанными через "," или при выводе состояния блоков списком в команде [i]Status[/i].

[h2]Выборка с учетом грида[/h2]
Грид или сетка, это совокупность блоков, статически соединенных друг с другом. Сабгрид или подсетка, эта совокупность блоков, соединенных с другим гридом через динамические блоки — поршни, шарниры, роторы. В Easy Play различаются три типа гридов:

[b]MyGrid[/b] (основной грид) — блоки, находящиеся на гриде, в котором установлен ПБ Easy Play

[b]AllGrid[/b] —  MyGrid и все сабгриды, соединенные с основным через динамические блоки — роторы, шарниры, поршни

[b]MyShip[/b] — AllGrid и все что пристыковано к нему через коннекторы

[b]Имя_Грида[/b] — точное указание имени грида с учетом написания. Может применяться для управления пристыкованными через коннектор кораблями. Например, "[u]Unlock Connector on SE Escape Pod[/u]" отсоединит все коннекторы шатла с именем "SE Escape Pod"

Уточнение грида производится с использованием ключевого слова [b]on[/b]. Например
[code]
Over of Ion Thruster Forward on MyGrid = 50%
IncreaseOverride Ion Thruster Forward on MyGrid
[/code]
Такое уточнение позволит исключить перехват управления трастеров других кораблей, пристыкованных к вашем через коннекторы. Если грид не указан, то как и в Easy Automatition, выборка производится для всех доступных блоков, т.е. для [b]MyShip[/b].

[i]Замечание[/i]: гриды, присоединенные через активный блок-соединитель считаются частью того грида, к которому они присоединены.

-------------------------------------------------------------------------------------------------------------------------------------------
If/Else. Простая логика
-------------------------------------------------------------------------------------------------------------------------------------------
Использование логических выражений [b][i]If/Else[/i][/b] полностью унаследовано от Easy Automatition 2.0 и позволяет использовать простую бинарную логику с использованием традиционных операций сравнения: [b]=[/b] равно, [b]!=[/b] не равно, [b]<[/b] меньше, [b]>[/b] больше. В Easy Play к ним еще добавлены операции: [b]?[/b] — входит в строку и [b]!?[/b]  — не входит в строку, применяемые для анализа строчных данных.

Логические блоки последовательности действий разделяются традиционно фигурными скобками "{}", но в отличии от оригинала их не нужно теперь указывать с новой строки. Типичное логическое выражение выглядит так:
[code]
\x = Angle of MyRotor
IF Position Of MyPiston on MyGrid > \x {
  ...
} Else If Value OF x = 90.0 {
  ...
} else {
  ...
}
[/code]
Обратите внимание на регистр написания ключевых слов [b][i]If / Else / Of / On[/i][/b] их можно оформлять в любом виде, но вот последовательность операндов сравнения всегда идет слева направо. Т.е. сначала указывается свойство или переменная, значение которой анализируется, затем одна из логических операций, и в конце значение, с которым нужно сравнить. Перестановка операндов не допускается.
[code]
* это неверное оформление, хотя условие тоже самое
IF \x < Position Of MyPiston on MyGrid {
  ...
* тоже неверно, так как второй операнд включает обращение к переменной в полной форме
} else if Position Of MyPiston on MyGrid < Value of x {
  ...
}
[/code]
Теперь обратите внимание на сравнение значения переменной "x"  первом и втором условии [b][i]if[/i][/b]. 

Во-первых, если переменная используется в первом операнде, то обращаться к ней можно как в полной "[u]Value of x[/u]", так и в сокращенной "[u]\x[/u]" форме. Если переменная используется во втором операнде, то обращаться к ней можно только в короткой форме "[u]\x[/u]". 

Во-вторых, точность вычисления при сравнении задается вторым операндом, поэтому в выражении указан угол поворота ротора не просто 90, а 90.0 Это означает, что под условия равенства подойдут все значения угла поворота, математическое округление которых до первой десятичной точки даст 90.0, т.е. углы 90.01235, 90.0439, значение 89.786 к таковым не относится, поскольку результат округления будет равен 89.8.

Для роторов и шарниров, особенно при повороте на высоких скоростях, это важное условие. На практике точные значения углового положения ротора редко бывают целочисленными, т.к. ротор обладает инерцией и, в зависимости от веса присоединенного грида, может колебаться около заданного значения, но никогда его не достигнет.

Новые операции вхождения: [b]?[/b] и [b]!?[/b] позволяет определить содержится или нет указанное значение в анализируемом тексте. Сравнение производится без учета регистра. Например:
[code]
if Data of Camera Lidar ? "GPS:" {
  \coord = Data of Camera Lidar
  Fly to \coord at 30
  Fly Start
}
[/code]
Это пример межскриптовой коммуникации с другим моим скриптом [url=steamcommunity.com/sharedfiles/filedetails/?id=2559196981]Raycast Lidar[/url], который в случае наличия цели по лучу лидара помещает данные границы объекта в CustomData камеры, которая используется в качестве лидара. После чего их можно считать и использовать в качестве точки назначения для автопилота. 

Здесь условное выражение как раз проверяет наличие вхождения "GPS:" в поле CustomData блока с именем "Camera Lidar" и в случае нахождения ее помещает координаты GPS в автопилот через переменную "coord" и активирует его.

[i]Замечание[/i]: для сравнения с пустой строкой используется "=", а в качестве второго операнда "" (две двойные кавычки)

[h3]Вычисление логических выражений[/h3]
Логические выражения бывают простыми, когда используются одиночные операторы сравнения типа "=", "!=", "<", ">" или "?" и сложными, когда используются удвоенные операторы сравнения типа "==", "<<", ">>" или "??".

Надо понимать, что в качестве левого операнда выступает часто не один блок, а несколько 
однотипных блоков, полученных при выборке свойства блока. Вычисление простых логических выражений производится до совпадения условия хотя бы для одного блока. 

Например, если вы хотите узнать есть ли открытые двери, то логическое выражение
[code]
if Open of Door = True {
  ...
}  
[/code]
будет истинным если открыта хотя бы одна дверь. Если вы хотите проверить, все ли двери на корабле закрыты, то нужно использовать удвоенный оператор сравнения:
[code]
if Open of Door on MyGrid == False {
  ...
}  
[/code]
Напомню, что по умолчанию выборка блоков распространяется на все гриды, в том числе и на присоединенные через коннекторы. Так что если ваш корабль пристыкован к станции, на которой так же есть двери, имена блоков которых содержат "Door", то чтобы не затронуть и их тоже, при запросе нужно уточнять грид для которого выполняется поиск блоков.

[h3]Переменные в именах блоков[/h3]
При анализе свойств блоков иногда возникает необходимость в проверить значение блока, имя которого формируется с учетом значения переменной. Это бывает удобным при настройке сценария. Например:
[code]
@var {
controller = "Cockpit"
x = 0
}
@damp_off {
\x = Damp of \controller
* это будет работать
if \x = False  {
   Damp of \controller = True
}
* а это - нет
if Damp of \controller = False  {
   Damp of \controller = True
}
[/code]

-------------------------------------------------------------------------------------------------------------------------------------------
Cond. Составная логика
-------------------------------------------------------------------------------------------------------------------------------------------
Новый оператор [b]Cond[/b] позволяет вычислять сложные не бинарные логические выражения с применением логики "и/или". В основном он был введен для того, чтобы сократить в @-блоке количество бинарной логики [b][i]if/else[/i][/b]. Например, если вы хотите вывести на экран статус ворот открывающихся поршнем, то нужно будет написать что-то типа
[code]
if Position of Piston Escape = 0 {
  Write to LCD Info = "Ворота закрыты"
} else {
  Write to LCD Info = "Ворота открыты"
}
[/code]
Подобных условий может быть много, что увеличивает размер кода сценария. Вместо написания этих 5 строк можно обойтись всего парой если использовать переменную:
[code]
\x = cond(Position of Piston Escape = 0 : закрыты : открыты)
Write to LCD Info = "Ворота \х"
[/code]

Как видно из примера, синтаксис [b]Cond()[/b] прост: сначала идет условие, затем разделитель":" (двоеточие), затем значение, которое нужно присвоить при совпадении условия, затем снова ":" и последним идет значение, которое нужно присвоить, если условие не совпадает.
[quote]
Если значение, которое нужно установить, или переменная, которую нужно проверить, содержит двоеточие ":", то для правильной трансляции нужно использовать двойные кавычки, например: [i]cond("\color" ? 250 : "0:0:240" :"250:0:0")[/i]
[/quote]

Теперь рассмотрим случай, когда ворота открываются поршнем, который стоит на роторе и ворота будут считаться открытыми только тогда, когда поршень выдвинут на 7 м, а ротор развернут на 180 градусов. В простой логике придется написать вложенный [b][i]if[/i][/b]:
[code]
if Position of Piston Escape = 7 {
  if Angle of Rotor Escape = 180 {
    Write to LCD Info = "Ворота открыты"
  } else {
    Write to LCD Info = "Ворота закрыты"
  }
} else {  
  Write to LCD Info = "Ворота закрыты"
}
[/code]
С применением [b][i]cond()[/i][/b] все будет выглядеть гораздо компактнее:
[code]
\x = cond(Position of Piston Escape = 7 & 
          Angle of Rotor Escape = 180 : открыты : закрыты)
Write to LCD Info = "Ворота \х"
[/code]

Как видно из примера, [b]Cond()[/b], подобно [b]math()[/b] из Easy Automatition, допускает многострочную запись, что удобно если условий больше одного. При таком оформлении желательно, чтобы каждая новая строка не начиналась с символа-разделителя — в примере это "&" и ":". 

Для логики "или" используется одиночный разделитель "|" с помощью которого задачу определения положения ворот можно было бы решить так:
[code]
\x = cond(Position of Piston Escape < 7 | 
          Angle of Rotor Escape != 180 : закрыты : открыты)
Write to LCD Info = "Ворота \х"
[/code]

Все переменные, используемые в синтаксисе [b]Cond[/b], должны указывать в краткой форме с применением "\" (обратного слэша):
[code]
\x = 50
\speed = Speed of MyShip
\x = cond(\speed = 0 : Stoped : \x)
Echo = Скорость: \x
[/code]

-------------------------------------------------------------------------------------------------------------------------------------------
Условные циклы или замыкания
-------------------------------------------------------------------------------------------------------------------------------------------
Как и Easy Automatition, Easy Play не имеет специальных операторов циклов, потому что их можно реализовать теми средствами, которые есть в языковых конструкциях скрипта. Для того, чтобы организовать цикл достаточно условного оператора [b][i]if[/i][/b] и вызова по ссылке самого себя.

В свое время при создании [url=steamcommunity.com/sharedfiles/filedetails/?id=2468325731]реплики APC-M577[/url] из фильма "Чужие 2", я использовал это, чтобы плавно изменять высоту подвески бронетранспортера, чтобы он не подпрыгивал при резкой установке ее в крайнее верхнее положение -50 см.
[code]
@wheel_up {
* уменьшить высоту подвески группы колес  
DecreaseHeight (APC, Wheels)
* если высота переднего левого колеса больше -49 см
if Height of Wheel 5x5 FL > -0.49
{
* выполнить задержку в 1/4 сек  
   Delay 250
* продолжить уменьшать высоту вызовом самого себя    
   @wheel_up 
}
}
[/code]
За одно выполнение команды "[u]DecreaseHeight[/u]" APC-M577 поднимался на 11 см. Т.о. для подъема в крайнее верхнее положение с 0, цикл выполнялся 5 раз после чего сценарий завершал работу по условию. Поэтому такой цикл и называется условным. В традиционном программировании подобный цикл называется [b][i]While[/i][/b].

Возможность Easy Play изменять представление глобальных переменных внутри @-блока позволяет организовать и итерационный цикл [b][i]For[/i][/b], связанный с достижением переменной граничного значения. Вот как это можно сделать на примере сценария 10-и секундного обратного отсчета:
[code]
@vars {
x = 10
}
@countdown {
if Value of x > 0 {
   Write to LCD Alert = "Обратный отсчет: \x"
* уменьшим значение глобальной переменной на 1 с помощью math()
   \x = math(\x - 1)
* ждем 1 сек   
   Delay 1000
* и вызываем сами себя   
   @countdown
}
Write to LCD Alert = "Эвакуация!"
* вернем значение переменной для возможного повторного использования сценария
\x = 10
}
[/code]

Прервать выполнение подобного замыкания можно вызовом ПБ Easy Play с параметром [b]reset[/b]

-------------------------------------------------------------------------------------------------------------------------------------------
Delay/When. Задержка выполнения
-------------------------------------------------------------------------------------------------------------------------------------------
Easy Play имеет два оператора, которые на время приостанавливают выполнение скрипта.
Это связано в первую очередь с использованием динамических блоков — поршней, роторов, 
шарниров, створок герметичных ворот, дверей, словом со всеми блоками для которых переход из одного состояния в другое требует времени.

[h2]Delay. Приостановка на заданное время[/h2]
[b]Delay[/b] позволяет приостановить работу скрипта с точностью до 1 милисекунды. 1 сек 
соответствует 1000 мс, поэтому чтобы задержать выполнение на нужное количество секунд,
нужно просто умножить их количество на 1000.
[code]
Delay 3000
Write to LCD Info = "Прошло 3 сек."
[/code]
По прошествии указанного времени [b]Delay[/b] передаст управление следующей за ним команде. Если включен режим отладки, то время задержки будет выводится в область Echo скрипта. 

[b]Hint:[/b] Используйте [i]Delay(100)[/i] для задержки после стыковки корабля, если автоматизация требует последующего анализа состояния блоков присоединенного через коннектор грида.

[h2]When. Ожидание наступления события[/h2]
[b]When[/b], как и [b]If[/b] является простым бинарным логическим оператором и обладает теми же возможностями и синтаксисом, но в отличии от него он приостанавливает действия скрипта до наступления определенного условным выражением события. После того, как событие наступило, происходит передача управления следующей за [b][i]When[/i][/b] команде сценария, "{}" не требуются.
[code]
* запуск движения поршня к отметке 7 м со скоростью 1
Move MyPiston to 7 at 1
* ожидание достижения отметки
When Position of MyPiston = 7
* вывод на LCD о завершении события
Write to LCD Info = "Ворота открыты"
[/code]
Все просто и очевидно, за исключением одного момента — в реальной игре событие может
просто не наступить, например из-за деформации брони, которое помешает поршню достичь
нужной отметке и скрипт просто зависнет. 
[quote]
Поделать с этим ничего нельзя, но можно на выполнить команду [b]Reset[/b], чтобы ПБ вышел из цикла.
[/quote]
В остальном оператор [b]When[/b] очень удобен и если неизвестно примерное время наступления события, то он позволяет дождаться этого момента с точностью до 1 тика таймера. 

Используйте [b]When[/b] с учетом того, в каких условиях динамический блок будет работать и если нет полной уверенности, что все пойдет как надо, то лучше использовать оператор задержки [b]Delay[/b], который так же задерживает выполнение скрипта, но на точно указанное вами время.

Если включен режим отладки, то время задержки будет выводится в область Echo скрипта. Если нет, его можно получить командой [i]Sync of Script[/i], если использовать ее сразу после [b]When[/b].

Это может быть полезно для тех, кто предпочитает автоматизацию на таймерах, т.к. с помощью [b]When[/b] можно с точностью до милисекунды узнать время, за которое событие происходит. Например, узнать за какое время в игре полностью открываются створки герметичных ворот.

-------------------------------------------------------------------------------------------------------------------------------------------
Math. Математика
-------------------------------------------------------------------------------------------------------------------------------------------
Как и оригинальный скрипт, Easy Play может использовать многострочные математические
выражения при инициализации переменных или в качестве правого операнда логических
выражений. Поддерживаются следующие математические операции:

[b]+[/b] (плюс) — сложение
[b]-[/b] (дефис) — вычитание
[b]*[/b] (звездочка) — умножение
[b]/[/b] (косая черта) — деление

Приоритет вычисления операция задается  вручную при помощи "()" круглых скобок. Например, для правильного вычисления выражения[i] 3+4*5 = 23[/i] нужно расставить круглые скобки так: [i] 3+(4*5)[/i], чтобы получить 23. Использование в качестве операндов значений свойств блоков осталось неизменным:
[code]
@vars {
level = math(
  (Position of Piston/2.5) + 
  (abs(Angle of Rotor*0.5) - 1) 
}
[/code]
В примере показано многострочное оформление математического выражения и приоритет, заданный при помощи "()". Во избежании ошибок вычисления при  записи выражения в несколько строк не следует начинать новую строку с символа операции.

Дополнительно к математическим операциям реализованы функции:

[b]abs()[/b] — абсолютное значение
[b]int()[/b] — округление до целого числа

[h3]Извлечение числового значения[/h3]
Команда [b]math()[/b] умеет извлекать из операндов, представленных переменными или свойствами блоков, первое по счету числовое значение с десятичной точкой, а так же вычислять выражения в строчном представлении. Например:
[code]
* установит х = 100 от значения давления в 100%
\x = math(Info[3] of Airvent)

* установит x = -31.789 - первое по счету число в GPS-координатах
\x = math("GPS:База:-31.789:67.978:29.17965")

* поместит в х информацию от Build Progress проектора, например "4/20"
\x = Info[4] of Projector
* вычислит х = 0.2 от строчного представления деления 4/20
\x = math(\x)
[/code]
[b]Замечание:[/b] в последнем случае трансляция строчного представления математического выражения должна осуществляться через переменную, как показано в примере. Попытка прямого вычисления через свойства блока [i]math(Info[4] of Projector)[/i] вызовет 419 ошибку.

-------------------------------------------------------------------------------------------------------------------------------------------
Token. Текст с разделителем
-------------------------------------------------------------------------------------------------------------------------------------------
Для анализа текстовых данных и организации вывода часто требуется извлечь часть текста с применением разделителя. Такие части принято называть "токенами". Например, что того чтобы вывести тип отсканированного по лидару объекта, вам потребуется второй токен из полного формата GPS координат, который команда Scan помещает в поле "Свои данные" камеры.

Синтаксис команды [b]Token[/b] похож на синтаксис полного обращения к переменной [b]Value[/b], где имя переменной указывается без лидирующей "\": [b]Token[/b][N] [b]of[/b] var. В квадратных скобках "[]" указывается порядковый номер токена. Отсчет начинается с 1. 

Если значение в [] превышает допустимое или неверное, то возвращается 1-й токен. Без [] возвращается количество токенов. 

Начиная с версии 1.32 в [] скобках можно указывать имя токена, чтобы получить его индекс в строке. Если токена в строке нет, то возвращается 0. Если строка токенов включает числа, а требуется получить его индекс, то значение в [] следует заключить в двойные кавычки:
[code]
\jump = "5:6:7:8:9:10"
* x = 1, а без кавычек x = 9
\x = Token["5"] of jump
[/code]

[h3]Извлечение токена[/h3]
Извлечение и установка токена всегда производится [u]только для переменной[/u]:
[code]
* scan помещает в поле "Свои данные" камеры GPS:Asteroid:x:y:z
Scan of Camera Lidar at 10000
* считываем данные в переменную lidar
\lidar = Data of Camera Lidar
* извлекаем второй токен по разделителю "двоеточие" = Asteroid
Echo = "{Token[2] of lidar}"
* подсчет количества токенов в тексте = 5
Echo = "{Token of lidar}"
* это неверно, извлечение возможно только из переменной
Echo = "{Token of Data of Camera Lidar}"
[/code]

Построчное извлечение выполняется командой [b]TokenLine[/b]. В тексте должны присутствовать переносы строки или символ новой строки [i]\N[/i], чтобы применить эту команду
[code]
@var {
menu = "Ship status
Drone status
Exit from menu"
}
@test {
* извлечет вторую строку = Drone status
Echo = "{TokenLine[2] of menu}"
}
[/code]

[h3]Изменение токена[/h3]
Если значение в "[]" превышает допустимое, неверно или команда используется без "[]", то устанавливается 1-й токен:
[code]
@var {
color = "0:0:0"
menu = "Ship status
Drone status
Exit from menu"
}
@test {
* установит переменную color = 255:0:0 - красный цвет
Token[1] of color = 255
* заменит вторую строку переменной menu на "View drone"
TokenLine[2] of menu = "View drone"
}
[/code]

-------------------------------------------------------------------------------------------------------------------------------------------
Status. Состояние блока
-------------------------------------------------------------------------------------------------------------------------------------------
Основой практически любой автоматизации является анализ текущего состояния того или
иного игрового блока, которые можно устанавливать через панель управления и о которых рассказано в разделе "Свойства и действия". Однако игровой движок использует больше свойств, чем те, что доступны через панель управления. Для доступа к ним используются две  команды — [b]Status[/b] и [b]Info[/b].

[h2]Status. Текущее состояние блока[/h2]
Для разных блоков существую различные промежуточные состояния, в которых они могут
находиться — батарея может заряжаться, створки ангара — закрываться, турель — стрелять, а коннектор быть готовым к стыковке. 

Ниже представлен список состояний для различных типов блоков, которые доступны по команде [b]Status of[/b] [i]Blocks[/i] [b]on[/b] [i]Grid[/i], где Blocks — выборка блоков, а Grid — необязательное уточнение грида MyGrid или AllGrid (по умолчанию MyShip).

[table equalcells=1]
[tr][td]Ассемблер[/td][td] Idle, Producing, Stopped — если нет слитков для производства, в ()
режим работы: Assembly, Disassembly[/td][/tr]
[tr][td]Бак (О2/Н2)[/td][td] чдт = процент заполнения бака, в () режим накопителя: StockOn, StockOff[/td][/tr]
[tr][td]Батареи[/td][td] чдт = процент заряда, в () состояние зарядки: Auto, Recharge, Discharge[/td][/tr]
[tr][td]Вентиляция[/td][td] Depressurized, Depressurizing, Pressurized, Pressurizing[/td][/tr]
[tr][td]Ветрогенератор[/td][td]чдт = текущая отдача в Вт, в () процент от максимальной отдачи[/td][/tr]
[tr][td]Двери, ворота, створки ангара[/td][td]Opening, Open, Closing, Closed[/td][/tr]
[tr][td]Коннектор[/td][td] Unconnected, Connectable, Connected, в () имя припаркованного корабля[/td][/tr]
[tr][td]Курсовое оружие (пулеметы, ракетницы)[/td][td] Idle, Ready, в () остаток боезапаса[/td][/tr]
[tr][td]Лазерная антенна[/td][td] Idle, RotatingToTarget, SearchingTargetForAntenna, Connecting, Connected, OutOfRange[/td][/tr]
[tr][td]Очиститель[/td][td] Idle, Producing[/td][/tr]
[tr][td]Прыжковый двигатель[/td][td]чдт = дальность прыжка в км, в () текущее состояние: Charging, Ready, Jumping)[/td][/tr]
[tr][td]Проектор[/td][td]строка с разделителем ":" из 8-и токенов: 
1=наличие чертежа в проекторе, True/False 
2=общее число блоков в чертеже
3=общее число функциональных блоков в чертеже
4=число блоков, которые можно сварить
5=недостающие функциональные блоки
6=недостающие конвееры
7=недостающие блоки брони
8=общий % недостающих блоков (повреждения), чдт
[/td][/tr]
[tr][td]Поршень[/td][td] Extending, Extended, Retracting, Retracted, Stopped — если скорость установлена в 0[/td][/tr]
[tr][td]Ротор и шарнир[/td][td] Attached, Detached[/td][/tr]
[tr][td]Сенсор[/td][td] Idle или имя игрока/грида дружественных фракций[/td][/tr]
[tr][td]Солнечная панель[/td][td]чдт = текущая отдача в Вт, в () процент от максимальной отдачи[/td][/tr]
[tr][td]Соединитель[/td][td] Idle, Merged[/td][/tr]
[tr][td]Сортировщик[/td][td] Whitelist, Blacklist — режим, а не список фильтра[/td][/tr]
[tr][td]Таймер[/td][td] Countdown — если ведется отсчет[/td][/tr]
[tr][td]Турели автоматические[/td][td] Idle, Target — видит цель, Aimed — нацелена, в () остаток боезапаса[/td][/tr]
[tr][td]Шасси и магнитные пластины[/td][td]Unlocked, ReadyToLock, Locked[/td][/tr]
[/table]

Команда [b]Status[/b] возвращает состояние первого найденного блока из выборки. Для других типов блоков возвращается [i]Active[/i], если блок работоспособен. Если блок выключен через панель управления выводится [i]Offline[/i], если поврежден выше предела разрушения — [i]Damage[/i]. 

Все указанные в правом столбце таблицы значения, за небольшим исключением, — внутри игровые, поэтому при анализе их нужно указывать полностью и с учетом написания:
[code]
If Status of MyConnector = Connectable {
  Lock MyConnector
}
[/code]
[i]Замечание:[/i] если дополнительная информация, выводимая в "()" круглых скобках, не нужна, то используйте [b]StatusX[/b] вместо [b]Status[/b]. StatusX для проектора вернет % повреждений.

[h2]Status. Вывод состояния выборки блоков[/h2]
Несколько иной синтаксис команды, позволяет получить список состояния всех блоков выборки: [b]Status[/b] [i]Blocks[/i] [b]of[/b] [i]Grid[/i], где где Blocks — выборка блоков, а Grid — обязательное уточнение грида MyShip, MyGrid или AllGrid.

После выполнения такой команды будет сформирован построчный список состояний всех блоков, который можно вывести на LCD-панель. Например следующий сценарий:
[code]
@ship_status {
Write to LCD Status = "< Connector Status>\N
{Status Connector of MyGrid}\N
<Assembler Status>\N
{Status Assembler  of MyGrid}"
}[/code]
Выведет на панель с именем "LCD Status" состояние всех коннекторов и сборщиков
[quote][previewimg=26067589;sizeFull,inline;ep_12.jpg][/previewimg][/quote]
Это удобнее, чем последовательное перечисление всех сборщиков и коннекторов корабля, для отображения их состояния командой [b]Status[/b].

[i]Замечание:[/i] если дополнительная информация, выводимая в "()" круглых скобках, не нужна, то используйте [b]StatusX[/b] вместо [b]Status[/b].

[h3]Status[Active]. Активность блоков[/h3]
Для просмотра сколько блоков из выборки активно используется команда [b]Status[Active][/b]:
[code]
* выведет 1/3 если один из трех реакторов группы (Reactors) активен
Echo = "{Status[Active] (Reactors) of MyShip}"
[/code]
[i]Hint:[/i] полученное значение можно использовать через переменную для трансляции [b]math()[/b]. Допустимо сокращение до [b]StatusA[/b]

[h3]Status[Middle]. Среднее значение[/h3]
Для блоков, состояние которых возвращается числом с "." десятичной точкой с помощью [b]Status[Middle][/b] можно получить среднее значение:
[code]
* если кислорода с учетом всех баков менее 75%
if Status[Middle] Oxygen Tank of MyShip < 75 {
  * если в О2/Н2 Генераторах есть лед
  if InvX of O2/H2 Generator > 0 {
   * включить все генераторы
    OnOff_On O2/H2 Generator
  }
}
[/code]
[i]Замечание:[/i] для блоков другого типа возвращается 0. Допустимо сокращение до [b]StatusM[/b]

[h3]Status[Total]. Суммарное значение[/h3]
Применима для блоков, состояние которых возвращается числом с "." десятичной точкой с помощью:
[code]
* если уровень отдачи менее 100 Вт
if Status[Total] Solar Panel of MyShip < 100 {
    * запускаем генератор
    OnOff_On Gydrogen Generator
}
[/code]
[i]Замечание:[/i] для блоков другого типа возвращается 0. Допустимо сокращение до [b]StatusT[/b]

-------------------------------------------------------------------------------------------------------------------------------------------
Info. Информация о блоке
-------------------------------------------------------------------------------------------------------------------------------------------
Вы можете видеть ее в области Echo при выборе блока в списке в панели управления. [b][i]Info[/i][/b] позволяет получить построчный или поименный доступ к этой информации, если это имя можно выделить и вернуть соответствующее ему значение.
[previewimg=31769887;sizeFull,floatLeft;ep_21.jpg][/previewimg]
.
Синтаксис команды: [b]Info[Val] of[/b] [i]Blocks[/i] [b]on[/b] [i]Grid[/i], где Blocks — выборка блоков, Val — номер строки, или имя свойства  в квадратных скобках, а Grid — необязательное уточнение грида MyGrid или AllGrid (по умолчанию MyShip). 

Если [] нет, или в них указан номер несуществующей строки или свойства, то будет возвращен весь блок дополнительной информации.

Блок дополнительной информации в выводе команды [b]Show[/b] на LCD располагается выше "Свойства" и ниже названия корабля. Блок может быть пустым, а его содержимое зависит от языка, который установлен в Space Engineers (не в локализации Easy Play). В данном случае это русский язык.
[quote][previewimg=25689458;sizeFull,inline;ep_03.jpg][/previewimg][/quote]

Построчный доступ к свойству осуществляется путем указания номера строки из которого нужно взять значение, а именной — имени свойства которое указано в строке до ":" (двоеточия)
[code]
\x = Info[3] of Airvent 1
\y = Info[Давление] of Airvent 1
* в обеих случаях будет выведено 100.00%
Echo = "Значение в 3-й строке: \x & \y"
if Value of x ? "100.00" {
  Write to LCD Info = "Помещение герметично"
}
[/code]
Первый способ обращения не зависит от установленного в игре языка, а второй — зависит, т.к. свойство будет называться у всех по разному. Если вы планируете выкладывать крафт в Steam, то лучше использовать первый способ. 

Анализ значения чаще всего лучше выполнять с помощью оператора вхождения в строку "?", но если свойство блока представлено числом, без дополнительных символов справа, то можно использовать и другие логические операторы.

После выхода Automotons Update появились блоки "искусственного интеллекта", которые имеют динамическую и не уникальную информацию о блоке. Например блок AI Offensive имеет две строки [i]Status[/i]  и для получения последнего значения этого свойства следует указать перед ним восклицательный знак "!" — [i]!Status[/i]

-------------------------------------------------------------------------------------------------------------------------------------------
Rename. Переименование блоков
-------------------------------------------------------------------------------------------------------------------------------------------
Эта команда позволяет переименовывать блоки в пакетном режиме, что позволяет достаточно быстро оптимизировать их названия для последующей автоматизации. 

Синтаксис команды включает ключевой слово [b]Rename[/b], обычную выборку по имени, ключевое слово [b]to[/b]  и последовательность префиксов, формирующих новое имя. Вместо выборки блоков можно использовать так же все блоки грида и подсетки: [i]MyGrid, AllGrid[/i], а вот [i]MyShip[/i] ссылается здесь на имя основного грида, который указывается в системной панели во вкладке "[u]Инфо[/u]".

[h3]Префиксы для переименования[/h3]
Алгоритм переименования полностью изменен относительно Easy Automatition и основан на использовании префиксов, начинающихся с символа "#" (решетка):

[b]#n2[/b] — автоинкримент, где 2 количество цифр (м.б любым числом), префикс используется для порядкового индексного переименования блоков
[code]
* все гироскопы будут с именами Gyro 001, Gyro 002 ... Gyro 999
Rename Gyroscope to Gyro #n3
[/code]

[b]#r3[/b] — случайное число, где 3 количество цифр (м.б любым числом), этот префикс можно использовать для присвоения уникальных имен автоматически распечатываемых дронов, на которых установлен Easy Play. Для MyShip префиксы [i]#*[/i] и [i]#def[/i] не обрабатываются.
[code]
* в результате получится что-то типа Drone_607
Rename MyShip to Drone_#r3
[/code]

[b]#def [/b] — ссылка на оригинальное внутри игровое имя, которое вы можете увидеть при выводе свойств и действий на консоли и в области Echo по команде [b][i]Show[/i][/b]. 
[previewimg=25689458;sizeFull,inline;ep_03.jpg][/previewimg]
.
Этот префикс используется для переименования всего крафта с языков, отличных от английского. Он особенно удобен для переименования иероглифических имен блоков. Просто попробуйте выполнить этот сценарий для [url=steamcommunity.com/sharedfiles/filedetails/?id=2596714186]вот такого крафта[/url] и посмотрите, что получится.
[code]
@grid_rename {
Rename MyGrid to #def
}
[/code]

[b]#*[/b] (звездочка) — ссылка на текущее имя, из которого с помощью "-" (минус) можно убрать лишнее вхождения

Типичной задачей переименования является добавление или замена префикса перед именем блока на всем гриде. С помощью EasyPlay это можно легко сделать:
[code]
Rename MyGrid to New #*-Old
[/code]
Здесь [i]Old[/i] — старый префикс который нужно заменить, а [i]New[/i] — новый префикс. Если, к примеру ваши блоки начинались с префикса [i]My[/i]: My Gyroscope, My Battery..., а вы хотите чтобы они назывались Me Gyroscope, Me Battery... то вместо [i]Old[/i] нужно указать [i]My[/i], а вместо [i]New[/i] — [i]Me[/i]. Если у блока нет префикса [i]Old[/i], то префикс [i]New[/i], то префикс New будет добавлен к имени блока.

[quote]
Для того чтобы не переименовывать блоки сразу, можно предварительно посмотреть результат, ограничив всю последовательность префиксов символами "~". После выполнения такой команды "Rename" изменения имен блоков не произойдет, а результат будет выведен в область Echo. Если результат группировки префиксов вас устраивает, просто уберите символы "~"  и повторно запустите сценарий.
[/quote]

[h3]Переименование из панели управления[/h3]
С помощью локальных переменных легко написать @-блок, который будет выполняться из строки "[u]Аргумент[/u]" ПБ Easy Play
[code]
@rename {
Rename \1 to \2  
}  
[/code]
Запуск сценария с параметрами типа [i]rename(Gyro, #* #n1)[/i] добавит к имени всех блоков, имя которых начинается с "Gyro" порядковый номер начинающийся с "1". 

Этот @-блок из 3-х строк позволит выполнять любые переименования прямо из панели управления. Для наглядности можно использовать фильтр по имени в панели управления, который расположено выше списка блоков.

[i]Замечание:[/i] с "-" (дефис) в оригинальном имени, конечно, есть проблемы, — если он в нем есть, то его нельзя удалить, но в остальном подобный алгоритм позволяет получать практически любые составные имена.

-------------------------------------------------------------------------------------------------------------------------------------------
Run. Межскриптовая коммуникация
-------------------------------------------------------------------------------------------------------------------------------------------
Любой сценарий Easy Play может запускать скрипты, расположенные в других программных блоках, с любым аргументом. Это позволяет организовать связь между различными скриптами и управлять ими в зависимости от условий. Например, можно переключать турель из ручного управления в автоматическое, передавать координаты целей скриптам управления ракет и т.п.

Обращение к другому программному блоку осуществляется с помощью команды [b][i]Run[/i][/b]. Аргументы могут указываться через знак "=" как в Easy Automatition или в круглых скобках "()":
[code]
Run PBL Fire = 1
Run PBL Fire(2, decoy)
[/code]
Выполнение с аргументом по умолчанию осуществляется либо внутриигровой командой [b]RunWithDefaultArgument[/b]  (сокращения не допускаются), либо короче - с аргументом "[i]defarg[/i]":
[code]
RunWithDefaultArgument PBL Fire
Run PBL Fire(defarg)
[/code]
Команда [b]Run[/b] выполняется для  первого найденного на корабле программного блока имя которого в точности совпадает с указанным. Для того, чтобы выполнить команду для всех блоков с указным именем используйте команду [b]RunAll[/b] с тем же синтаксисом. Применять уточняющие условия выборки, связанные с символами "!#?" не надо.

[i]Замечание:[/i] командой "Run" нельзя запустить (замкнуть на себя) ПБ Easy Play.

-------------------------------------------------------------------------------------------------------------------------------------------
Set. Настройка блоков по образцу
-------------------------------------------------------------------------------------------------------------------------------------------
Команда Set позволяет устанавливать свойство одного блока или выборки блоков по типу другого блока. Это позволяет легко настраивать однотипные блоки, имеющие большое количество настроек, например, LCD панели, лампы, подвеску и т.п. без необходимости их группировки или выбора в панели управления.

Синтаксис команды: [b]Set[/b] [i]выборка_блоков[/i] [b]on[/b] [i]блок_образец[/i], где [i]выборка_блоков[/i] — выборка блоков по имени по всем доступным гридам, а [i]блок_образец[/i] — точное имя блока с учетом написании, настройки которого будут использованы для установки значений свойств блоков выборки. Например:
[code]
Set #Light bridge on Light bridge 01
[/code]
Установит все настройки ламп освещения, имена которых начинаются с "Light bridge" по типу лампы с именем "Light bridge 01". В последнем случае уточнение имени блока-образца с помощью префикса "!" происходит автоматически и в нем не нужно использовать никакие другие префиксы уточнения.

Следующий сценарий в одну строку позволит настраивать блоки по образу прямо из панели управления через аргумент ПБ Easy Play:
[code]
@set {
Set \1 on \2
}
[/code]
[i]Замечание[/i]: настройка по образцу блоков, имеющих несколько экранов (поверхностей), производится командой [b][i]Surface[/i][/b], описанной в разделе "Настройка вывода LCD".

[h3]Пакетная настройка блоков[/h3]
Начиная с вер. 1.33 в качестве образца можно указывать не имя блока, а текстовые данные, где нужные вам значения свойств будут установлены пакетом в формате "Свойство = Значение" и перечислены команды, которые можно будет применить к нужному блоку:
[code]
\light = "OnOff_Off
Color = 255:0:0
Radius = 10
Blink Interval = 1
OnOff_On"
Set Light Bridge on "\light"
[/code]
Последнее значение всегда должно быть заключено в "" двойные кавычки. Вместо новой строки можно использовать разделитель [b]\N[/b]. Свойства необходимо указывать точно так, как они перечисляются в выдаче команды [b]Show[property][/b], а команды точно так как в выдаче [b]Show[action][/b]. Сокращения не допускаются.

Такая настройка называется [u]пакетной[/u]. Она позволяет устанавливать свойства блоков из хранимых значений и использовать типовые настройки в разных крафтах. Я, например, всегда настраиваю освещение рубки одинаково и гораздо удобнее хранить настройки отдельно, чем загружать в мир похожий корабль, чтобы вспомнить, как настраивается освещение.

[quote]
В пакете можно указывать только свойства и команды блоков из списка [b]Show[/b]. Другие команды EasyPlay не обрабатываются, кроме команды [b]AI[/b] (см. раздел "Другие свойства и команды")
[/quote]

[h3]Перепрошивка AI[/h3]
Еще одним применением такой настройки является перепрограммирование поведения AI-блоков. Это позволяет прямо на ходу менять настройки поведения блоков [u]AI Offensive[/u] и [u]AI Defensive[/u] переписывая их установки в пакетном режиме, которые можно хранить в поле "Свои данные" любого игрового блока.
[code]
\behavior = "AI = CycleOrbit
OffensiveCombatIntercept_OverrideCollisionAvoidance = True
OffensiveCombatCircleOrbit_CircleDistance = 800
SetTargetPriority_Largest
SetTargetingGroup_Weapons"
Set AI Offensive on "\behavior"
[/code]
Таким образом можно, например, "перепрошить" ракету или ударный дрон после его печати на принтере, изменив настройки, установленные в чертеже, изменив тем самым его поведение в зависимости от типа атакуемой цели.

-------------------------------------------------------------------------------------------------------------------------------------------
Data. Поле "Свои данные"
-------------------------------------------------------------------------------------------------------------------------------------------
Вы можете считывать и записывать информацию в поле "Свои данные" ([b][i]CustomData[/i][/b]) любого блока как целиком, так и с точностью до переменной, установленной в секции, если там используется оформление типа "[i]имя_переменной = значение_переменной[/i]". В таком формате оформлены настройки многих популярных скриптов, например [url=https://steamcommunity.com/id/Whiplash141/myworkshopfiles?browsefilter=myfiles&sortmethod=creationorder&section=items&appid=244850&requiredtags%5B%5D=IngameScript]скриптов Whiplash141[/url].

Обработка данных в поле CustomData производится с помощью линейки команд [b][i]Data[/i][/b]. Например, если поле "Свои данные" текстовой панели "LCD Info" содержит настройки:
[code]
[setup]
Font = 1.3
Color = 0:0:25
[/code]
то следующие команды:
[code]
* полностью очистит CustomData
[b]Data[/b] of LCD Info = ""

* добавит к существующим данным 5, в итоге Color = 0:0:255
[b]DataAdd[/b] of LCD Info = "5"

* добавит к существующим данным новую строку
[b]DataLine[/b] of LCD Info = "BgColor = 255:0:0"

* считает в переменную \y значение параметра Color (поиск зависит от регистра)
\y = [b]Data[Color][/b] of LCD Code

* установит значение переменной Color (установка зависит от регистра)
[b]Data[Color][/b] of LCD Info = 100:100:100

* перепишет CustomData (многострочная запись с использованием двойных кавычек)
[b]Data[/b] of LCD Info = "[setup]
Font = 1
Color = 255:0:0
BgColor = 255:255:255"
[/code]

Если при установке значения параметра он не будет найден, то к CustomData будет добавлена новая строка с этим параметром и значением через разделитель "=" (равно).

Вы можете так же использовать разделитель ":" (двоеточие) вместо "=". В этом случае для доступа к значениям параметров следует вставить ":" перед его именем. Например, мой скрипт [url=https://steamcommunity.com/sharedfiles/filedetails/?id=2559196981]Raycast Lidar[/url] выводит данные сканирования в следующем формате: 
[code]
Distance: 10703 m
Type: Asteroid
Size: 768 m
------------------------
* получения размера астероида
\size = math(Data[:Size] of LCD Lidar)
[/code]
[b][i]Замечание:[/i][/b] команда [b][i]Data[/i][/b] обрабатывает [u]только первый блок  из выборки[/u], поэтому лучше полностью указывать имя блока, чтобы работать с CustomData конкретного блока.

[h2]Чтение @-блока[/h2]
В отличии от Easy Automatition, Easy Play не умеет выполнять @-блок из CustomData другого игрового блока, но может считать его. Это свойство можно использовать, чтобы вынести часть информации за рамки кода своего ПБ, например для организации подсказок по управлению
[code]
@help {
Write to Control Seat Hold = "{Data[@help_\1] of Control Seat Hold}"
}
[/code]
Этот однострочный сценарий используется на тестовом крафте и позволяет выводить на основной экран станции управления подсказки для управления с помощью цифровых панелей. Имя блока указывается также как для чтения переменной с лидирующим "@".

Вызов @-блока "help" осуществляется через выполнение ПБ Easy Play  с аргументом "[u]help(N[/u])", где N — номер цифровой панели от 1 до 9, а CustomData контрольной станции содержит соответствующие @-блоки.
[code]
@help_1 {
#1 - Hydrogen on/off
#2 - Hydrogen Force on/off
#3 - Ion on/off
...
}
@help_2 {
#1 - Rescan Inventory
#2 - Switch screen mode
...
}
[/code]
Дополнительные способы установки значений со ссылкой на свойства блоков см. в разделе "Write. Запись на LCD".

-------------------------------------------------------------------------------------------------------------------------------------------
Write/Text. Запись и чтение LCD
-------------------------------------------------------------------------------------------------------------------------------------------
Запись возможна на любой экран (поверхность) блока, если он есть, за исключением
модуля выживания и медицинского блока. 

Запись производится линейкой команд [b][i]Write[/i][/b]. Номер экрана, на который выводятся данные, указывается вслед за командой в квадратных скобках "[]". Отсчет экранов начинается с нуля. Если номер не указан, то запись производится на нулевую поверхность.
[code]
* очистит экран панели
[b]Write[/b] to LCD Info = ""

* выведет на центральный экран кокпита время корабля
[b]Write[/b] to Industrial Cockpit[b][1][/b] = "{Time of MyShip}"

* выведет на последний экран Sci-Fi 4-х кнопочной панели
[b]Write[/b] to Button Panel[b][3][/b] = "Дверь закрыта"

* добавит к существующим данным "Открыто" или "Закрыто" 
\x = cond(Open of MyDoor = True : Открыто : Закрыто)
[b]WriteAdd[/b] to LCD Info = \x

* добавит к существующим данным новую строку 
[b]WriteLine[/b] of LCD Info = "Коннектор {Status of MyConnector}"

* многострочный вывод на экран
[b]Write[/b] to LCD Info = "Управление
#1 - включить
#2 - выключить"
[/code]

Команды [b][i]Write[/i][/b] и [b][i]Data[/i][/b] могут включать в себя прямой вывод свойств блоков, которые должны быть заключены в фигурные скобки "{}", а правый операнд после знака "=" должен быть заключен в двойные кавычки. 

При этом поддерживается построчный вывод свойств всей выборки блоков. Например, чтобы вывести на экран состояние всех коннекторов корабля, достаточно одной команды:
[code]
* выведет построчно состояние всех блоков, имя которых начинается с "Connect"
Write to LCD Info = "{Status of Connect}"
[/code]
Многострочный вывод, а так же трансляция свойств блоков в фигурных скобках "{}", должны быть заключены в двойные кавычки. Чтобы каждый раз не оформлять многострочную запись, можно использовать "\N" для перехода на новую строку.

Команда [b][i]Write[/i][/b] автоматически переключает экран в режим "[u]текст и изображение[/u]" за исключением когда нужно вывести игровой скрипт (см. ниже).

[h2]Чтение и запись экрана [/h2]
Новая, по сравнению с Easy Automatition, команда [b][i]Text[/i][/b] позволяет считывать и записывать любой экран блока целиком.
[code]
* чтение содержимого экрана в переменную
Value of screen = Text of LCD Info

* добавление заголовка и перезапись всего содержимого экрана 
Text of LCD Info = "Содержимое экрана \N\screen"
[/code]
Запись на экран при помощи [b][i]Text[/i][/b], в отличии от [b][i]Write[/i][/b], производится без смены режима экрана. Например, если на экране в момент записи отображается системный скрипт типа "Гравитация", то он там и останется. 
[quote]
При записи с помощью [b][i]Text[/i][/b] транслируются только переменные. Свойства блоков, заключенных в фигурные скобки "{}", не обрабатываются.
[/quote]

[h2]Вывод игрового скрипта[/h2]
Начиная с ver.1.3 EasPlay позволяет выводить на экран игровые скрипты типа часы, уровень гравитации, сетку горизонта, наличие цели и т.п. Для этого используется команда [b]WriteScript[/b] с тем же синтаксисом, что и команда текстового вывода [b]Write[/b].
[code]
* выведет сетку горизонта на экран
WriteScript to LCD info = TSS_ArtificialHorizon
[/code]
Здесь после знака "=" указано внутри игровое имя скрипта, которое можно узнать, если установить нужный вам скрипт вручную, а затем через панель управления и вывести в область эха свойство [i]Script[/i]
[code]
Echo = "{Script of LCD Info}"
[/code]

-------------------------------------------------------------------------------------------------------------------------------------------
Настройка вывода LCD
-------------------------------------------------------------------------------------------------------------------------------------------
Позволяет настроить шрифт, цвет, выравнивание и другие параметры экрана (поверхности) для оформления вывода. С помощью этой линейки команд легко реализовать сценарий настройки параметров одного экрана по типу другого. 

Часть команд линейки пересекаются с доступными свойствами обычной текстовой LCD-панели, но Easy Play делает их доступными не только для нее, но и для любой поверхности, номер которой указывается в квадратных скобках "[]": 
[code]
* установить размер шрифта центрального экрана промышленного кокпита
FontSize of Industrial Cockpit[1] = 4.5
[/code]
Для настройки можно использовать следующие команды:

[b]FontSize[/b] — размер шрифта, число с десятичной точкой от 0.1 до 10.0

[b]FontFace[/b] — шрифт, обычно Debug, Monospace или любой доступный из списка в панели управления, имя шрифта контекстнозависимое

[b]TextAlign[/b] — выравнивание текста на экране, одно из значений: Left, Right, Center

[b]FontColor[/b] — цвет шрифта, RGB-триада с разделителем ":", например синий = 0:0:255

[b]Padding[/b] — отступ текста от краев панели, десятичное число от 0 до 100

[b]BgColor[/b] — цвет экрана, RGB-триада с разделителем ":", например красный = 255:0:0

[b]BgRotate[/b] — угол вращения экрана, одно из значений: 0, 90, 180, 270 (только для LCD-панелей)

[b]Image[/b] — изображение, размещаемое на экране, например, "Danger" - значек опасности. Полный список изображений приведен в панели управления при настройке экрана. Имя изображения контекстнозависимое.

[b]Text[/b] — чтение/записи информации на экран (см. раздел "Запись и чтение LCD")

[b]Script[/b] — имя системного скрипта, например "TSS_EnergyHydrogen" - энергия и водород. Полный список скриптов приведен в панели управления при настройке экрана. Имя скрипта контекстнозависимое.

[h2]Surface. Комплексная настройка экрана[/h2]
Команда позволяет выполнить настройку основных параметров экрана (поверхности) одной строкой и устанавливать настройки одного экрана по типу другого.
[code]
* детальная настройка экрана
FontFace of LCD Info = Debug
FontSize of LCD Info = 3
FontColor of LCD Info = 255:255:200
TextAlign of LCD Info = Center
Padding = 20
BgColor = 0:100:200

* настройка одной строкой, сокращения параметров упорядочены по детальным настройкам
Surface of LCD Info = "ff=Debug|fs=3|fc=255:255:200|ta=center|tp=20|bc=0:100:200"
[/code]
Присутствие всех параметров настройки в команде [b][i]Surface[/i][/b] необязательно, порядок их следования также не имеет значения. Разделитель параметров — вертикальная черта "|".

Такой подход позволяет написать простой сценарий настройки параметров одного экрана
по аналогии с другим экраном и вызвать его из панели управления ПБ Easy Play со двумя 
параметрами: [i]surset(Button HallL[0], Button HallR[1])[/i], где первым указывается экран,
настройки которого нужно установить, а вторым — экран настройки которого нужно взять. 
[code]
@surset {
* читаем в переменную настройки 2-го экрана
\x = Surface of \2
* устанавливаем по ним настройки первого
Surface of \1 = \x
}
[/code]

А этот сценарий позволит установить все экраны 4-х кнопочной Sci-Fi с именем [i]Button Right[/i] панели по типу 2-й кнопки панели с именем [i]Buttons Left[/i].
[code]
@but4 {
\x = Surface of \2
Surface of \1[0] = \x
Surface of \1[1] = \x
Surface of \1[2] = \x
Surface of \1[3] = \x
}
[/code]
Запуск сценария через строку аргументов ПБ: [i]but4(Button Right, Buttons Left[1])[/i]
[quote][previewimg=25824472;sizeFull,inline;ep_11.jpg][/previewimg]
* цвет последней кнопки после выполнения сценария на тестовом корабле изменен вручную[/quote]
[b]HINT.[/b] Одинаковую настройку всех экранов 4-х кнопочных Sci-Fi панелей можно выполнить по первой кнопке с помощью [i]but4(Sci-Fi Panel, Sci-Fi Panel)[/i], где [i]Sci-Fi Panel[/i] — имя вашей панели.

-------------------------------------------------------------------------------------------------------------------------------------------
Система меню на LCD
-------------------------------------------------------------------------------------------------------------------------------------------
Начиная с ver.1.3 EasyPlay синтаксис команды [b]Write[/b] дополнен суффиксом [i]Menu[/i], с помощью которого можно без труда организовать систему многоуровнего меню. Сценарий  меню вы будете писать сами, а EasyPlay просто будет выводить указатель текущего пункта.

Синтаксис команды: [b]WriteMenu[/b](Index) [b]to[/b] LCD[N] = "Text", где [i](Index)[/i] —  число от 1,  порядковый номер текущего пункта меню; [i]LCD[/i] — имя блока LCD-панели или экрана кокпита; [i][N][/i] — число от 0, порядковый номер экрана для мультиэкранных блоков (если не указано используется первый экран); [i]Text[/i] — многострочный текст меню или текст с разделителем "новая строка" \N.
[code]
* выведет на панель с именем LCD Info текст, с указателем ">" перед первой строкой
WriteMenu(1) to LCD Info = "Ship status
Drone control
Show horizon
Exit from menu"
* выведет тоже самое, здесь новая строка представлена разделителем \N
WriteMenu(1) to LCD Info = "Ship status\NDrone control\NShow horizon\NExit from menu"
[/code]
[previewimg=31214826;sizeFull,inline;ep_14.jpg][/previewimg]
.
Здесь для вывода заголовка меню вместо [b]WriteMenu[/b] используется команда [b]WriteLineMenu[/b], которая по аналогии с [b]WriteLine[/b] просто добавляет вывод к текущему содержимому панели с новой строки. Соответственно [b]WriteAddMenu[/b] добавит текст меню без переноса строки.

[h2]Сценарий двухуровнего меню[/h2]
Для того, чтобы написать меню с помощью EasyPlay потребуется несколько переменных:
[code]
@var {
* имя панели для вывода
lcd = "LCD Info"
* меню 1-го уровня
main = "Ship status\NDrone control\NShow horizon\NExit from menu"
* меню 2-го уровня
invent = "Ship status
Turret status
Stock ammo
Stock ingots
Main menu"
* текущие значения указателя пункта и текста выводимого меню
mopt = 1
menu = ""
x = 0
}
[/code]

Теперь выведем меню на экран, чтобы получить то, что представлено на картинке выше. Для этого создадим @-блок с именем "menu" (или любым другим)
[code]
@menu {
* при первом вызове текст меню пустой, поэтому помещаем в \menu текст главного меню
if \menu = "" { 
   \menu = \main 
}
* эта команда подсчитывает количество строк в меню, чтобы перемещать указатель
\x = TokenLine of menu
* выводим заголовок и само меню
Write to \lcd = "= Ship Control Menu =\N"
WriteLineMenu(\mopt) to \lcd = \menu
}
[/code]

Вывести на экран меню можно запустив EasyPlay с аргументом menu через панель управления. 
[previewimg=31215042;sizeFull,inline;ep_18.jpg][/previewimg]
.
Займемся перемещением указателя, для этого в @menu добавим логику его обработки, для этого будем анализировать значение первого аргумента \1, переданного в сценарий в ():
[code]
@menu {
if \menu = "" { 
   \menu = \main 
}
\x = TokenLine of menu
* при выводе меню с аргументом menu(down) увеличим текущее значение указателя на 1
if \1 = "down" {  
  \mopt = math(\mopt+1)
  if \mopt > \x { 
     \mopt = 1 
  }
* при выводе меню с аргументом menu(up) уменьшим текущее значение указателя на 1
} else if \1 = "up" {  
  \mopt = math(\mopt-1)
  if \mopt = 0 { 
     \mopt = \x 
  }
}
Write to \lcd = "= Ship Control Menu =\N"
WriteLineMenu(\mopt) to \lcd = \menu
}
[/code]

Теперь добавим логику выбора пункта и выхода из меню
[code]
@menu {
if \menu = "" { 
   \menu = \main 
}
\x = TokenLine of menu
if \1 = "down" {  
  \mopt = math(\mopt+1)
  if \mopt > \x { 
     \mopt = 1 
  }
} else if \1 = "up" {  
  \mopt = math(\mopt-1)
  if \mopt = 0 { 
     \mopt = \x  
  }
* при обращении с аргументом menu(exit) через панель управления
} else if \1 = "exit" {
*  очистим экран и остановим сценарий
  Write to \lcd = ""
  Stop
* при обращении с аргументом menu(select)  через панель управления
} else if \1 = "select" {
* если текущее значение в \menu соответствует меню 1-го уровня main
  if \menu = \main {  
* вызываем сценарий его обработки
     @menu_main
* если текущее значение в \menu соответствует меню 2-го уровня invent
   } else if \menu = \invent { 
* вызываем сценарий его обработки, соответственно
     @menu_invent
   }
}
Write to \lcd = "= Ship Control Menu =\N"
WriteLineMenu(\mopt) to \lcd = \menu
}
[/code]

Осталось написать сценарии обработки для каждого меню. Для этого можно анализировать текущее значение указателя в переменной \mopt, а можно содержимое строки меню, на который он в настоящий момент указывает. Сравнение производится с учетом регистра:
[code]
* сценарий обработки меню 1-го уровня, используем указатель
@menu_main {
* если указатель указывает на 1-й пункт, который отвечает за вызов меню 2-го уровня
if \mopt = 1 {
* устанавливаем указатель на первый пункт нового меню
  \mopt = 1
* помещаем в \menu текст меню второго уровня и возвращаемся в блок @menu для вывода
  \menu = \invent
} else if \mopt = 3 { 
* если выбрана третья строка, выводим на экран системный скрипт сетки горизонта
  WriteScript to \lcd = TSS_ArtificialHorizon
* и не возвращаемся в @menu, чтобы его вывод не перекрыл запущенный скрипт
  Stop
} else {
  @menu(exit)
}
}
* сценарий обработки меню 2-го уровня, анализируем строку, на которой стоит указатель
@menu_invent {
* эта команда позволяет получить значение строки по ее номеру в тексте меню
\x = TokenLine[\mopt] of menu
* если строка содержит "Ship"
if \x ? "Ship" {
*  то запускаем сценарий вывода общего состояния корабля
   @ship_status 
   Stop
* если строка содержит "ingot"
} else if \x ? "ingot" {
* то выводим на экран результат инвентаризации слитков на гриде
   WriteLine to \lcd = "{Invent ingot[ * ] of MyGrid}"
   Stop
* если строка содержит "ammo"
} else if \x ? "ammo" {
* то выводим на экран результат инвентаризации патронов на всем корабле, 
* включая все сабгриды, на тот случай, если есть кастомные турели
  WriteLine to \lcd = "{Invent ammo[ * ] of MyShip}"
  Stop
* если строка содержит "Turret"
} else if \x ? "Turret" {
* выводим состояние турелей
  WriteLine to \lcd = "{Status Turret of MyGrid}"
  Stop 
} else if \x ? "menu" {
  \mopt = 1
  \menu = \main
}
}
[/code]

Вот как будет выглядеть экран при выборе 4-го пункта в меню 2-го уровня. Поскольку для вывода инвентаризации используется команда [b]WriteLine[/b], то ее вывод будет добавлен на экран ниже меню, что удобно, т.к. позволяет ориентироваться, что именно выводится, а меню при этом остается активным и вы можете сразу переместить указатель к другому пункту:

[previewimg=31215287;sizeFull,inline;ep_19.jpg][/previewimg]
.
Собственно все. Осталось поместить обращение к основному сценарию в блоке @menu на цифровую панель станции управления кораблем и можно работать. Для этого сидя в кресле управления нужно нажать Ctrl+G и вызвать на экран панель настройки цифровых клавишь.

Затем последовательно перетащить на свободное место в панели иконку с изображением ПБ EasyPlay, выбрать в меню "Запустить" и ввести параметры обращения к меню:

[previewimg=31215483;sizeFull,inline;ep_20.jpg][/previewimg]
.
Для #1 в поле "Аргумент" нужно ввести [b]menu[/b], это вызовет меню на экран LCD-панели
Для #2 в поле "Аргумент" нужно ввести [b]menu(down)[/b], это переместит указатель вниз
Для #3 в поле "Аргумент" нужно ввести [b]menu(up)[/b], это переместит указатель вверх
Для #4 в поле "Аргумент" нужно ввести [b]menu(select)[/b], это выберет текущий пункт меню
Для #5 в поле "Аргумент" нужно ввести [b]menu(exit)[/b], это завершит работу с меню и уберет его

[b]Hint:[/b] логику управления можно сократить с 5-и цифровых клавиш до 2-х. Например, вывод меню на экран можно совместить с выбором в меню, а указатель перемещать только в одном направлении, т.к. согласно приведенному сценарию он будет перемещаться циклически. Кнопку выхода можно вообще убрать, поскольку в меню есть опция выхода.

-------------------------------------------------------------------------------------------------------------------------------------------
Роторы, шарниры, поршни
-------------------------------------------------------------------------------------------------------------------------------------------
Одной из самых полезных функций Easy Play является упрощенное управление перемещением динамических блоков при помощи одной команды вне зависимости от их текущего положения.

Роторы и шарниры поворачиваются на нужный угол с заданной скоростью при помощи команд [b]Rotate[/b] и [b]ShortRotate[/b]. Поршень выдвигается на заданную длину с заданной скорость при помощи команды [b]Move[/b]. Например:
[code]
* повернуть ротор на 160 град. со скоростью 5 об./мин. против часовой стрелки
Rotate MyRotor to 160 at -5
* повернуть ротор на -30 град. со скоростью 1 об./мин. направление вычисляется автоматически
ShortRotate MyRotor to -30 at 1
* выдвинуть/задвинуть поршень на 7 со скоростью 1
Move MyPiston to 7 at 1
[/code]
Команды не сокращаются и могут быть набраны в любом регистре. Все команды изменяют значения верхней и нижней границ блока — это нужно учитывать, если автоматизация использует так же стандартное действие "[u]Reverse[/u]", доступное для динамических блоков этого типа. Если ротор или шарнир блокированы в момент выполнения команды, то блокировка будет снята автоматически.
[quote]
При установке значений, превышающих допустимые, выводится сообщение об ошибке и сценарий останавливается, так как предполагается, что дальнейшее его выполнение связано с новой позицией блока.
[/quote]

[h2]Управление поршнем[/h2]
Поршень перемещается при помощи команды [b]Move[/b] MyPiston [b]to[/b] Distance [b]at[/b] Speed где [i]MyPiston[/i] — имя поршня, выборки или группы поршней, [i]Distance[/i] — расстояние, на которое нужно выдвинуть поршень, [i]Speed[/i] — скорость с которой должен двигаться поршень. 

Предельные расстояния для поршней малой и большой сетки и направление перемещения определяются автоматически. Текущее положение поршня определяется свойством [b]Position[/b]. 
[code]
if Position of MyPiston = 0 {
   Move MyPiston to 3.5 at 1 
}
[/code]

[h2]Поворот роторов и шарниров[/h2]
Синтаксис команд [b][i]Rotate[/i][/b] и [b][i]ShortRotate[/i][/b] унаследован от Easy Automatition:

[b]Rotate/ShortRotate[/b] MyRotor [b]to[/b] Angle [b]at[/b] Speed, где [i]MyRotor[/i] — имя ротора, группы или выборки роторов, [i]Angle[/i] — угол на который нужно повернуть (целое число от -360 до 360), [i]Speed[/i] — скорость поворота (целое число от -30 до 30 для роторов большой сетки и от -60 до 60 для малой сетки). Положительное число скорости поворота выполнит поворот по часовой стрелке, а отрицательное — против часовой.

Команда [b][i]ShortRotate[/i][/b] поворачивает ротор на заданный угол по кратчайшему пути. Формула поиска минимального угла поворота изменена относительно оригинального скрипта.

Для шарниров используется тот же синтаксис, что и для роторов, но угол, на который можно
повернуть шарнир, устанавливается в диапазоне от -90 дл 90 град, а команда [b][i]ShortRotate[/i][/b] работает так же как и команда [b][i]Rotate[/i][/b].

Текущий угол поворота шарнира или ротора можно узнать с помощью свойства [b]Angle[/b]
[code]
if Angle of MyRotor = 90 {
   ShortRotate MyHinge to 30 at 1
}
[/code]

Во избежании Clang-а, при завершении поворота желательно устанавливать скорость вращения равной нулю, а ротор или шарнир блокировать. Для ротора, угол которого установлен в ноль, команда блокировки может изменять значение текущего угла с 0 на 360 градусов. Это нужно учитывать при использовании логических выражений:
[code]
\x = cond(Angle of MyRotor = 0 | Angle of MyRotor = 360 : 0 : 1)
* если ротор в нулевой позиции
if Value of x = 0 {
  * выдвигаем поршень
  Move MyPiston to 5 at 1
}
[/code]

-------------------------------------------------------------------------------------------------------------------------------------------
Контроллер управления кораблем
-------------------------------------------------------------------------------------------------------------------------------------------
Easy Play обеспечивает доступ к свойствам любого контроллера, который может управлять кораблем. Имя контроллера нужно [b]указывать точно[/b], или вместо имени можно попробовать использовать [b]MyShip[/b]. В этом случае будет использован первый найденный контроллер, который конструктивно соединен с гридом на котором установлен программный блок Easy Play.

Используя MyShip в качестве имени, можно также устанавливать свойства контроллера, например [i]Damp of MyShip = True[/i] - включить гасители корабля, но обращаться с этим нужно аккуратно. Например свойство [i]AutoPilot[/i] есть только у блока удаленного управления и попытка установить его для кокпита приведет к 318 ошибке.

[h3]Свойства Operate & OperateAxis[/h3]
[b]Operate[/b] определяет, занимает ли персонаж указанный контроллер (сидит в кокпите, пилотском кресле, станции управления и т.п) или нет. Может быть сокращено до "Oper".

При использовании [b]MyShip[/b] будет возвращено имя контроллера который в настоящий момент занимает персонаж или [i]False[/i], если ни один контроллер не занят. Можно использовать для автоматизации, связанной с присутствием персонажа на борту.
[code]
* если персонаж в кокпите
if Oper of MyCockpit = True {
* закрываем двери  
  Close Door of MyGrid
}
[/code]

[b]OperateAxis[/b] определяет использует ли персонаж клавиши управления кораблем по осям при помощи клавиш управления WASD. Возвращает [i]True[/i] или [i]False[/i]
[code]
@var {
* определяет контроллер в котором находится персонаж
cont = Operate of MyShip
x = 0
}
@test {
\x = OperAxis of \cont
* если кнопка управления WASD нажат выводим эхо
if \x = True {  Echo = "Operate!" }
}
[/code]

[h2]Группы команд[/h2]
Несколько групп команд, позволяют определить текущие параметры корабля (скорость, массу, и т.д) и окружающего пространства (высоту над поверхностью планет, наличие гравитации и т.п) 

Порядок следования ключевых слов и регистр слов значения не имеет, свойства группы можно сокращать до первых 3-х символов ([i]Nat[/i] вместо [i]Natural[/i], [i]Alt[/i] вместо [i]Altitude[/i] и.п.), но имя группы следует указывать полностью:

[b]Группа Gravity[/b] — гравитация, число с десятичной точкой от 0, без ключа возвращает суммарную гравитацию с учетом искусственной и натуральной

[i]Natural[/i] — натуральная гравитация планеты
[i]Artificial[/i] — искусственная гравитация, которую дают генераторы гравитации корабля

[b]Группа Planet[/b] — положение относительно планеты, при отсутствии натуральной гравитации или ключа возвращает -1

[i]Position[/i] — триада GPS-координат центра ближайшей планеты
[i]Elevation[/i] — триада GPS-координат позиции контроллера относительно центра планеты
[i]Altitude[/i] — число с десятичной точкой, высота контроллера над поверхностью планеты

[b]Группа Speed[/b] — без ключа возвращает базовую скорость корабля в м./сек

[i]Linear[/i] — линейная скорость в м/сек
[i]Angular[/i] — угловая скорость в рад./сек

[b]Группа Mass[/b] — без ключа возвращает полную масса корабля в кг, включая пристыкованные через коннекторы гриды

[i]Base[/i] — базовая масса корабля в кг.
[i]Physical[/i] — полная масса корабля в кг. с учетом игрового мультипликатора массы груза

[b]Группа Grid[/b] — информация и координаты

[i]Name[/i] — имя корабля во вкладке "Инфо" системной панели (не сокращается)
[i]SizeL[/i] — длина корабля в метрах (не сокращается)
[i]SizeW[/i] — ширина корабля в метрах (не сокращается)
[i]SizeH[/i] — высота корабля в метрах (не сокращается)
[i]Park[/i]  —  имя_грида:имя_коннектора к которому припаркован корабль (не сокращается)
[i]Position[/i] — триада GPS-координат центра масс грида, на котором установлен контроллер
[i]Margin[NN][/i] — триада GPS-координат границы грида, рассчитывается вверх от контроллера на удалении, равному NN метров или максимальной размерности грида по трем его осям ДхШхВ. 
[quote]
Если в момент исполнения команды в приемнике сообщений через радиоантенну есть данные в формате GPS, то расчет границы производится по вектору связывающему центр масс и GPS-координаты приемника. Такое решение позволяет безопасно автоматически подлететь к кораблю (см. "Обмен через радиоантенну").
[/quote]

Ниже приведен пример вывода параметров корабля на LCD-панель с использованием разных контроллеров, любой из которых можно использовать для получения нужных свойств:
[code]
* используется первый доступный контроллер
\myname = Grid Name of MyShip
* используется удаленное управление
\mypos = Grid Pos of Remote Control
* используется кокпит
\mygrav = Art Gravity of MyCockpit
\myspeed = Speed of MyShip
\mycargo = math(Mass of MyShip - Base Mass of MyShip)

Write to LCD Info = "\myname
Длина: {Grid SizeL Of MyShip} м.
Ширина: {Grid SizeW Of MyShip} м.
Высота: {Grid SizeH Of MyShip} м.

Скорость: \speed м/сек
Вес груза: \mycargo кг
Координаты: \mypos"
[/code]

-------------------------------------------------------------------------------------------------------------------------------------------
Автопилот. Автоматизация полета
-------------------------------------------------------------------------------------------------------------------------------------------
Автоматизация обеспечивается блоками дистанционного управления и AI Flight (Move), который имеет более высокий приоритет, если у него включен "искусственный интеллект".

[h3]Управление автопилотом[/h3]
Обеспечивается группой команд "Fly", для их использования на корабле должно быть установлен блок дистанционного управления. Перед выполнением команд, убедитесь, что ИИ AI Flight (Move) выключен: [i]ActivateBehavior of <блок> = False[/i], где [i]<блок>[/i] — имя блока AI Flight.

[b]Fly Start[/b] — включить автопилот

[b]Fly Stop[/b] — выключить автопилот

[b]Fly Clear[/b] — очистить список точек навигации, с ver.1.202.068 не использовать, команда нарушает работу автопилота, оставлена на будущее
 
[b]Fly to[/b] GPS [b]at[/b] Speed — добавить к списку точек навигации координаты [i]GPS[/i] (с ver.1.202.068 заменить список) и ограничить скорость [i]Speed[/i] — число с десятичной точкой от 0 до 100. 

Так же устанавливается: направление полета — вперед, в один конец, а так же режимы "избегать столкновений" и "парковка". Примерный сценарий с установкой точки назначения для автопилота:
[code]
\coord = "GPS:База:-62664.81:-80178.37:-27915.08:#"
Fly to \coord at 30
Fly Start
[/code]

Для изменений настроек автопилота, определяемых командой [b]Fly to[/b], используйте стандартные свойства самого блока автопилота:
[code]
* отмена режима "избегать столкновения"
CollisionAvoidance of MyRemote = False
* отмена режима "парковка"
DockingMode of MyRemote = False
* вместо Fly Start можно активировать автопилот иначе
AutoPilot of MyRemote = True
[/code]
После достижения заданной точки она будет удалена из списка навигации автопилота.

[h3]Разворот на точку GPS[/h3]
До ver.1.202.068 установка 0-й скорости для автопилота позволяло развернуть корабль по координатам точки назначения относительно ориентации блока дистанционного управления, после чего автопилот прекращал работу. Теперь автопилот не выключается, но задачу разворота из статического положения все же можно решить менее тривиальным способом:
[code]
* заносим GPS-координаты точки на которую нужно развернуться и устанавливаем скорость = 5
Fly to \coord at 5
* запоминаем текущие GPS-координаты блока удаленного управления
\x = "{Grid Pos of Remote Control}"
* запоминаем в переменную дистанцию от текущей точки здесь она равна 0
\y = Distance \x of Remote Control
* запускаем автопилот
Fly Start
* корабль начнет разворот на месте на нужную точку и затем начнет движение
* со скоростью 5 м/с, когда удаление от первоначальной точки превысит 3 метра
When \y > 3
* выключаем автопилот
Fly Stop
[/code]
Этот сценарий хорошо работает в космосе, но в гравитации разворот происходит не на заданную точку, а в направлении ее проекции на поверхность планеты. Сама же точка может при этом оказаться выше или ниже корабля.

-------------------------------------------------------------------------------------------------------------------------------------------
Инвентаризация корабля
-------------------------------------------------------------------------------------------------------------------------------------------
Две команды [b][i]Inventory[/i][/b] и [b][i]InventoryX[/i][/b] (по аналогии с популярным скриптом [url=steamcommunity.com/sharedfiles/filedetails/?id=822950976]Alutomatic LCDs 2.0[/url]) позволяют получить информацию о грузе корабля, находящемся в любых модулях, имеющих отсеки для хранения руд, слитков, компонентов, амуниции, патронов и т.п., которые отображаются в системной панели "Инвентарь".
[quote][previewimg=25701307;sizeFull,inline;ep_05.jpg][/previewimg]
Полная инвентаризация и вывод состояния корабля с помощью одного сценария Easy Play[/quote]
Инвентаризацию можно проводить как целиком по сеткам [i]MyShip[/i], [i]MyGrid[/i], [i]AllGrid[/i], так и по отдельным блокам или группе блоков (см. "Выборка блоков и гриды").

[b][i]Inventory[/i][/b] выводит детальную информацию, а [b][i]InventoryX[/i][/b] только число. Обе команды допускают сокращение до трех символов с "x" в конце
[code]
* вернет число и название: 1203 Cobalt
Inventory Ore[cobalt] of MyGrid
Invent Ore[cobalt] of MyGrid
Inv Ore[cobalt] of MyGrid

* вернет только число: 1203
InventoryX Ore[cobalt] of MyGrid
InventX Ore[cobalt] of MyGrid
InvX Ore[cobalt] of MyGrid
[/code]

[b][i]Inventory[/i][/b] выводит 6 групп игровых компонентов, названия которых можно сократить до первых 3-х символов.
[list]
[*] components — компоненты
[*] ores — руды
[*] ingots — слитки
[*] ammo — патроны
[*] arm — оружие/инструметы
[*] other — прочее
[/list]
В квадратных скобках "[]" указывается либо звездочка "*" для вывода всех элементов группы, либо полное внутри игровое название конкретного элемента на английском языке. При запросе слитков вслед за ними в круглых скобках "()" будет указано количество руды того же типа.

При использовании [noparse]"[*]"[/noparse] выводятся все элементы группы вне зависимости от их наличия. Чтобы не выводить элементы которых нет в инвентаре, следует установить [b][i]invempty = false[/i][/b] внутри кода скрипта EasyPlay.
[code]
Write to LCD Info = "
< Патроны >
[noparse]{Invent ammo[*] of MyShip}[/noparse]
< Уран >
{Invent Uranium of AllGrid}"
[/code]
Этот код выведет на LCD-панель все боеприпасы, имеющиеся на корабле, включая турели пристыкованных через коннекторы кораблей, и урановые слитки и руду только вашего корабля:
[quote]
< Патроны >
1200 Gatling 25x184 mm
4300 Turret 56x45 mm
120  Missile 200 mm
< Уран >
345 Уран (2450)
[/quote]

В Easy Play патроны NATO 25x184 и NATO 56x45 выводятся как патроны для Гатлинга и
внутренней турели соответственно. Так их проще визуально контролировать. 

Руда, слитки и компоненты учитывают их наличие во входной и выходной очередях сборщиков и очистительных заводов. Очередь разборки сборщиков не учитывается.

Вы можете проводить также частичную инвентаризацию выборки или группы блоков. В этом
случае инвентаризация будет выполнена для [i]MyShip[/i].
[code]
* руда и слитки железа в очистительных заводах
Write to Echo = "{Inv Iron of Refinery}"
* стальные пластины во всех контейнерах
Write to Echo = "{Inv Steel Plate of Container}"
* стальные пластины без учета пристыкованных кораблей
Write to Echo = "{Inv comp[Steel Plate] of AllGrid}"
* количество льда в генераторах 
Write to Echo = "{Inv Ice of O2/H2 Generator}"
[/code]
Названия элементов выводится на том языке, который установлен для локализации. Сортировка элементов групп выполняется только для внутри игровых названий на английском. 
[quote]
Перевод всех внутри игровых названий руд, компонентов, инструмента и т.п. вы можете найти в [url=https://steamcommunity.com/sharedfiles/filedetails/?id=2688952356]Обсуждениях[/url] к скрипту Easy Play[/quote]
Вы можете написать любой сценарий инвентаризации, определив свой порядок вывода, и вызывать его всякий раз, когда требуется посмотреть наличие нужных элементов. 

[b]HINT.[/b] Если требуется постоянное обновление данных, как в Automatic LCDs  2.0, то просто [u]заведите вызов сценария на таймер[/u] и замкните таймер на себя, но нужно понимать, что во-первых, ПБ Easy Play в каждый момент времени способен выполнять только один сценарий, а во-вторых, полная инвентаризация — достаточно затратная процедура. Обычно инвентаризации по запросу вполне достаточно для реальной игры.

-------------------------------------------------------------------------------------------------------------------------------------------
Обмен через радиоантенну
-------------------------------------------------------------------------------------------------------------------------------------------
Easy Play позволяет отправлять и принимать сообщения в радиусе действия радиоантенны, 
исключая собственные антенны, антенны сабгридов и припаркованных через коннектор кораблей. ПБ Easy Play используется и как источник и как приемник сообщений.

Любой сценарий может отправлять и считывать данные из приемника сообщений. Этот игровой механизм называется [i]Inter Grid Communication[/i] (Межсетевая коммуникация) — далее IGC.

Сеанс связи состоит из отправки одиночных текстовых сообщений любого формата — каждое новое сообщение удаляет предыдущее. С версии 1.3 возможна обработка очереди сообщений, если сообщения поступают одновременно из нескольких источников по одному каналу связи.

Имя канала связи устанавливается в переменной [b][i]igcTag[/i][/b] в коде скрипта (по умолчанию "EasyPlay"). Рекомендую изменить его, если скрипт используется в кооперативной игре или на сервере, чтобы обмен данными между кораблями шел по индивидуальному каналу связи.

Для отправки сообщений антенна должна быть включена и для нее должно быть разрешено вещание. Для приема сообщений антенна должна быть включена, а состояние вещания значения не имеет. Кроме того, если вы для безопасности собираетесь включать антенну только на момент передачи данных, то требуется примерно 300 мс, чтобы она стала готова к передаче. Учитывайте это в своих сценариях обмена.

Чтение и отправка сообщений осуществляется с помощью команды [b][i]Send[/i][/b]:
[code]
* отправка через первую доступную антенну грида
[b]Send[/b] = "Hello"
* отправка через антенну Antenna 1
[b]Send to[/b] Antenna 1 = "Hello"
* чтение сообщения из приемника
[b]Send of[/b] MyShip
* очистка приемника сообщений
[b]Send Clear[/b]
* очистка приемника и очереди сообщений
[b]Send Wipe[/b]
[/code]
Easy Play не предоставляет протокол обмена данными. Единственно, что он делает при получении IGC сообщения — анализирует его на вхождение "@", и пытается выполнить блок кода, следующего за ним. 

Например, прием [i]SE Mothership:@gpspos(SE Escape Pod)[/i] равнозначен запуску программного блока со скриптом Easy Play, с аргументом [i]gpspos(SE Escape Pod)[/i]. Очевидно, что такой вызов @-блока должен завершать сообщение, возможные параметры должны разделяться запятой "," и быть заключены в круглые скобки "()".

[h2]Сценарий радиобмена[/h2]
Примерный сценарий организации обмена данными между носителем [url=steamcommunity.com/sharedfiles/filedetails/?id=2688925369]SE Mothership[/url] и шатлом [url=steamcommunity.com/sharedfiles/filedetails/?id=2688920956]SE Escape Pod[/url], позволяющем в автоматическом режиме вернуться к носителю по вектору шатла, получив по запросу его координаты в процессе радиобмена:
[code]
* код сценария SE Mothership
* --------------------------
@var {
* имя корабля = SE Mothership
my = Grid Name of MyShip
* GPS-координаты границы корабля
pos = Grid Margin of MyShip
}
@gps_send {
* отправка своих координат в формате GPS через канал связи
Send = "\1:GPS:\my:\pos:#"
* очиска приемника в ожидании следующего запроса
Send Clear
}
[/code]
[code]
* код сценария SE Escape Pod
----------------------------
@var {
* имя корабля = SE Escape Pod
my = Grid Name of MyShip
* текущие GPS-координаты шатла
pos = Grid Position of MyShip
* приемник сообщений
rec = Send of MyShip
}
@fly_in {
* отправка запроса на носитель с указанием своего имени \my,
* текущих координат \pos и имени @-блока, который нужно выполнить
Send = "SE Mothership:@gps_send(\my,GPS:\pos:#)"
* ожидание ответа 0.5 сек
Delay 500
* обращаясь к переменной rec, читаем сообщение если оно содержит имя "SE Escape Pod"
if Value of rec ? \my {
  * то проверяем наличие префикса GPS-координат
  if Value of rec ? "GPS" {
    * если он есть, то заносим координаты в автопилот и устанавливаем макс. скорость 30 м/с
    Fly to \rec at 30
    * запускаем автопилот и летим к носителю
    Fly Start
  } else {
    Write to Echo = "No GPS coordinates"
  } 
  Send Clear
} else {
   Write to Echo = "Space silent"
}
}
[/code]

Этот сценарий, с небольшими дополнениями, реализован в примерных кораблях. Для того чтобы увидеть как он работает, нужно, управляя шатлом из кокпита, отлететь от материнского корабля на расстояние не менее 200 м. в любом направлении и выполнить для ПБ Easy Play шатла сценарий "fly_in" или нажать кнопку №6 на второй панели цифрового управления.
[quote][previewimg=25818119;sizeFull,inline;ep_09.jpg][/previewimg][/quote]

-------------------------------------------------------------------------------------------------------------------------------------------
Расстояние до точки GPS
-------------------------------------------------------------------------------------------------------------------------------------------
[h3]Свойство Distance[/h3]
Определяет расстояние от центра масс корабля до указанной точки GPS-координат в метрах. Может быть сокращено до "Dist". Синтаксис команды: [b]Distance[/b] [i]GPS[/i] [b]of MyShip[/b], где [i]GPS[/i], должно включать триаду координат.
[code]
\pos = "-240416.621:-2342908.495:360086.708"
* если дистанция до точки назначения меньше 500 м
if Distance \pos of MyShip < 500 True {
* включаем гасители, используя контроллер дистанционного управления
  DampenersOverride of Remote Control = True
}
[/code]

[h3]Команда Scan[/h3]
Позволяет определить расстояние от камеры до объекта сканирования с помощью механизма Raycast игрового блока "Камера". 

Синтаксис команды: [b]Scan of[/b] [i]MyCamera[/i] [b]at[/b] [i]Range[/i], где [i]MyCamera[/i] — точное имя блока камеры, а [i]Range[/i] — расстояние в метрах, на которое производится сканирование:
[code]
* сканировать камерой с именем "Camera Left" на расстояние 15000 м.
Scan of Camera Left at 15000
[/code]

Результат сканирования помещается в CustomData указанной камеры в расширенном (с ver.1.3) формате GPS-координат, включающем префикс GPS,  внутри игровой ID объекта, его имя, отношение с вами, размер, линейную скорость, тип объекта и координаты X:Y:Z
[code]
*   ID                 Name     Relate Size Vel   Type    X        Y         Z    
GPS:439630975968811834:Asteroid:Neutral:887:0.00:Asteroid:1002447.4:980106.9:1005785.5:
[/code]

[i]Имя объекта:[/i]  для дружественных объектов будет выведено полное имя грида. Например, название корабля. Для вражеских объектов общее название на языке локализации игры. Например, "большая структура".

[i]Тип объекта:[/i] Asteroid, CharacterHuman, CharacterOther, FloatingObject, LargeGrid, Meteor, Missile, None, Planet, SmallGrid, Unknow

[i]Отношение с вами:[/i] Enemies, Neutral, Owner.

[i]Размер объекта:[/i] целое число в метрах, если нужна повышенная точность, то можно указать количество знаков после десятичной точки в коде скрипта в переменной [i]scanSize[/i]

[i]Скорость объекта:[/i] линейная скорость в м/с с точностью до второго знака 

Получить нужную характеристику можно с помощью токена (см. "[u]Token. Извлечение из текста[/u]"):
[code]
Scan of Camera Lidar at 15000
\x = Data of Camera Lidar
Write to \lcd = "Имя: {Token[3] of x}\N Тип: {Token[7] of x}\N Размер: {Token[5] of x} m"
[/code]

Для передачи GPS-координат в автопилот то вместо [b]Scan[/b] нужно использовать одну из следующих команд: [b]Scan[Entity], Scan[Name], Scan[Type], Scan[Relate],[/b] которые поместят в поле "Свои данные" камеры координаты в обычном формате GPS (см. "[u]Контроллер и автопилот[/u]"). Если сканирование не достигло цели, то поле "Свои данные" будет пустым.
[quote]
При первом сканировании Raycast требует некоторое время на инициализацию (для 15 км задержка = 7.5 сек). После этого Raycast будет выполняться без задержек. Если переменная [b]debug[/b] скрипта EasyPlay установлена [i]true[/i], то время задержки будет выводиться в область Echo подобно команде [b]When[/b].
[/quote]

[h3]Определение расстояния до цели[/h3]
Совместное использование команд [b]Scan[/b] и [b]Distance[/b] позволяет легко определить дистанцию до цели сканирования:
[code]
* сканировать Camera на 10 км
Scan of Camera at 10000
* результат в переменную gps
\gps = Data of Camera
* если gps содержит префикс "GPS", то
if Value of gps ? GPS {
* измеряем расстояние до GPS-координат
\dist = Distance \gps of MyShip
* и выводим его на дисплей
Write to LCD Info = "Distance: \dist m"
} else {
Write to LCD Info = "No target"
}
[/code]

[i]Замечание:[/i] камера должна быть открыта, а не скрыта за стеклом или прозрачным LCD-дисплеем, т.к. Raycast измеряет расстояние по лучу до ближайшего объекта.

-------------------------------------------------------------------------------------------------------------------------------------------
Script. Свойство EasyPlay
-------------------------------------------------------------------------------------------------------------------------------------------
Для доступа к внутренним переменным скрипта EasyPlay используется обращение к свойствам несуществующего блока c именем "Script" через которое можно получить их значение.

[h3]Lng. Текущая локализация[/h3]
Может использоваться для вывода информации на LCD-панели в зависимости от локализации:
[code]
if Lng of Script = ru {
  Echo = Привет!
} else {
  Echo = Hello!
}
[/code]

[h3]Rand. Случайная цифровая строка[/h3]
В "[]" можно указать длину строки, без них возвращается случайное число из 3 цифр. Алгоритм генерации несложный, поэтому уникальность для коротких чисел не гарантируется
[code]
* выведет случайную последовательность из 5 цифр
Echo = "{Rand[5] of Script}"
[/code]

[h3]Sync. Системное время по модулю[/h3]
Позволяет определить посекундное время наступления события путем вычисления значения по модулю от числа секунд Unix TimeStamp. Значение интервала в секундах указывается в "[]":
[code]
if Sync[5] of Script = 0 {
   Echo = "Прошло 5 сек с момента запуска"
}
[/code]
Может использоваться для управления запуском @-блоков с использованием игрового блока Таймер. См. раздел "Автоматизация по таймеру" [b]Sync[/b] без "[]" вернет последнюю задержку по [b]When[/b], если в скобках указано не число, вернет текущий UnixTime в секундах.

[h3]UTC. Системное время[/h3]
Системное время в секундах.
[code]
Echo = "{UTC of Script}"
[/code]

-------------------------------------------------------------------------------------------------------------------------------------------
Другие свойства и команды
-------------------------------------------------------------------------------------------------------------------------------------------
Здесь описаны свойства и действия, которые не вошли в прочие разделы руководства.
[list]
AI — паттерны поведения блоков AI Offensive, AI Defensive и AI Basic
Jump — установка дальности прыжка прыжкового двигателя
Number — подсчет количества блоков выборки
Override — установка перехвата управления трастерами в %
Sound — мелодия динамика
Time — вывод локального время корабля по шаблону C#
[/list]

[h3]AI. Паттерны поведения[/h3]
Позволяет считать и установить значение из списка: [u]Attack pattern[/u] для блока [b]AI Offensive[/b], [u]Flee[/u] для блока AI Deffensive и [i]Mission[/i] для блока AI Basic, rкоторые определяю программу поведения, передаваемую ими блоку управления полетом AI Flight.

Каждый AI-блок имеет свои предустановленные значения, которые не сокращаются:

[table]
[tr]
[td]Имя блока 
------------------------------
[/td]
[td]Допустимое значение
--------------------------------------------------------------------------------------------------------------------------[/td]
[/tr]
[tr]
[td]AI Offensive (Combat) [/td]
[td]CycleOrbit, StayAtRange, HitAndRun, Intersept[/td]
[/tr]
[tr]
[td]AI Defensive (Combat)[/td]
[td]Always, Never, WhenTakingDamage, WhenTargetLocked[/td]
[/tr]
[tr]
[td]AI Basic (Task)[/td]
[td]FollowPlayer, FollowHome, AutoPilot[/td]
[/tr]
[/table]

[code]
* выведет текущую установку из списка Pattern Attac блока с именем AI Offensive
Echo = "{AI of AI Offensive}"
* установит значение в списке Mission блока с именем AI Basic
AI of AI Basic = FollowHome
[/code]

[h3]Jump. Прыжковый двигатель[/h3]
Позволяет считать или установить дальность прыжка в метрах (километрах)
[code]
* выведет установленную дальность прыжка в метрах
Echo = "{Jump of MyJump Drive}"
* выведет установленную дальность прыжка в километрах и текущий статус
Echo = "{Status of MyJump Drive}"
* установит дальность прыжка в километрах
Jump of MyJump Drive = 10
* стандартное свойство блока Jump Drive выведет дальность прыжка в %%
Echo = "{JumpDistance of MyJump Drive}"
* стандартное свойство блока Jump Drive установит дальность прыжка в %%
JumpDistance of MyJump Drive = 30
[/code]

[h3]Number. Подсчет количества блоков[/h3]
Возвращает число равное количеству блоков с указанным именем или входящих в группу.
[code]
* общее количество турелей всех типов имя которых начинается с "Turret"
Echo = "{Number of #Turret on MyShip}"
* общее количество вооружения в группе "Weapons"
Echo = "{Number of (Weapons)}"
[/code]

[h3]Override. Перехват управления трастерами[/h3]
Позволяет установить перехват управления трастерами в процентах, а не в kN, как это можно сделать при обращении к свойству "Override" обычным способом. Для установки укажите число от 0 до 100 и следующий за ним знак процента "%"
[code]
Over of Ion Thruster Forward = 50%
[/code]

[h3]Sound. Мелодия динамика[/h3]
Позволяет установить мелодию для динамика из "[u]списка звуков[/u]". Полный список мелодий и звуковых эффектов приведен в панели управления при настройке динамика. Имя мелодии контекстно зависимое. Если мелодия не выбрана, то возвращается пустая строка "".
[code]
@sound {
* считать в переменную игровое имя текущей мелодии
\x = Sound of Dynamic
Echo = Мелодия динамика: \x
* установить новую мелодию
Sound of Dynamic = SoundBlockAlert1
* проиграть
PlaySound Dynamic
}
[/code]
[i]Замечание:[/i] выбор установленного таким способом мелодия динамика может не отображаться в списке доступных мелодий в панели управления, но воспроизводится как надо.

[h3]Time. Локальное время корабля[/h3]
Возвращает время в формате MM/DD/YYYY H:M, где MM = месяц, DD = день, YYYY = год, H = часы в 24-х часовом формате, M = минуты.
[code]
Echo = "Date: {Time of MyShip}"
[/code]
Расширенный формат команды позволяет указать в квадратных скобках шаблон вывода даты и времени. Например [b]Time[dd/MM/yy HH:mm:ss][/b] выведет дату в международном формате и время в 24-х формате вместе с секундами. Возможные представления шаблонов можно посмотреть [url=https://www.c-sharpcorner.com/blogs/date-and-time-format-in-c-sharp-programming1]здесь[/url].

-------------------------------------------------------------------------------------------------------------------------------------------
Автоматизация по таймеру
-------------------------------------------------------------------------------------------------------------------------------------------
Для задач, требующих постоянного анализа состояния игровых блоков можно использовать автоматический вызов программного блока с параметром. Этот прием, который применялся в игру Space Engineers до 2018, когда блоки не умели самостоятельно перезапускаться.

Для его применения потребуется отдельный таймер в первый слот которого помещается ПБ EasyPlay, а во второй - таймер с командой "открыть".
[quote][previewimg=26179313;sizeFull,inline;ep_13.jpg][/previewimg][/quote]
Частота перезапуска задается временем задержки таймера и минимально может составлять 1 сек, чего вполне достаточно, чтобы решать таким способом большинство типичных задач, связанных с автоматизацией корабля.

Одной из таких задач, которую можно решить подобным способом является автоматическое закрытие дверей (AutoDoors). Ее можно легко выполнить с помощью EasyPlay не устанавливая отдельный ПБ для специального скрипта, которые можно найти в [url=https://steamcommunity.com/workshop/browse/?appid=244850&searchtext=autodoor&childpublishedfileid=0&browsesort=trend&section=readytouseitems&requiredtags%5B%5D=IngameScript&created_date_range_filter_start=0&created_date_range_filter_end=0&updated_date_range_filter_start=0&updated_date_range_filter_end=0]мастерской Steam[/url]:
[code]
@sync {
* если хотя бы один блок имя которого начинается с Door имеет статут "Открыто"
  if Status of #Door on AllGrid = Open {
     * закрываем все двери
     Open_Off #Door on AllGrid
  }
}
[/code]
Если установить задержки таймера равной 2 сек. то этого будет достаточно, чтобы двери на корабли закрывались автоматически, не мешая персонажу проходить сквозь них. 

Уточнение грида [i]AllGrid[/i] позволит скрипту определять только те двери, которые находятся на корабле и игнорировать двери, когда корабль припаркован через коннектор к космической станции, на которой так же могут быть двери имя которых начинается с "Door"

[h3]Автоматическая инвентаризация[/h3]
Другой популярной задачей является инвентаризация корабля, когда на LCD-панели выводится содержимое контейнеров, очистительных заводов, заполнение баков и пр. Не совсем понятно, зачем это нужно для автоматизации игрового процесса, но выглядит красиво. Эту задачу так же можно решить с помощью EasyPlay, добавив к приведенному выше коду еще одно условие:
[code]
@sync {
  if Status of #Door on AllGrid = Open {
     Open_Off #Door on AllGrid
  }
  * эта команда позволит обновлять вывод на LCD каждые 5 сек
  if Sync[5] of Script < 2 {
     Write to LCD Info = "
-= Руда =-
[noparse]Inventory ores[*] of MyGrid[/noparse]
-= Слитки =-
[noparse]Inventory ingot[*] of MyGrid"[/noparse]
  }
}
[/code]
По умолчанию инвентаризация блоков грида производится не чаще 5 сек, поэтому нет смысла нагружать ПБ EasyPlay посекундным обращением таймера, но есть один нюанс, связанный с вычислением интервала в 5 сек.

При выставлении задержки таймера в 2 сек, запуск сценария будет происходить во 2-ю, 4-ю, 6-ю и далее секунды. Команда [b]Sync[/b] вычисляет значение по модулю от системного времени обращения к скрипту. Поэтому интервал в 5 секунд попадет в эту последовательность только каждую 10-ю секунду. 

Чтобы избежать этого и используется условие "меньше 2", которое позволит выполнить сканирование инвентаря либо каждую 4-ю либо каждую 6-ю секунду, что не критично для задачи инвентаризации, но выполнять действия с точностью до секунды в реальной игре не получится. Это следует учитывать при анализе возможности решения задач автоматизации, связанных с  временным периодом.

Замечание: поскольку в один момент времени ПБ EasyPlay может выполнять только один сценарий, то лучше использовать два программных блока, один из которых будет решать задачи по таймеру, а второй - прочие задачи не связанные со периодом времени. Демонстрацию автоматизации по таймеру вы можете найти на корабле https://steamcommunity.com/sharedfiles/filedetails/?id=2725165752

[h3]Программный таймер[/h3]
Если требуется решать динамические задачи, связанные с программированием поведения корабля в бою, то обычного таймера, может оказаться недостаточно. В этом случае можно использовать вместо него отдельный программный блок, который будет запускать нужный сценарий с частотой 6 раз в секунду:
[code]
string pbn = "PB EasySync"; // имя блока EasyPlay, который управляет динамикой
string arg = "status"; // имя сценария, который будет запускаться
IMyProgrammableBlock sync = null;

public Program() { 
  Runtime.UpdateFrequency = UpdateFrequency.Update10;
}
public void Main(string argument, UpdateType updateSource) 
{
  if(sync == null) {
    List<IMyProgrammableBlock> pb = new List<IMyProgrammableBlock>();
    GridTerminalSystem.GetBlocksOfType<IMyProgrammableBlock>(pb,b => b.CubeGrid == Me.CubeGrid && b.CustomName == pbn);
    if(pb.Count > 0) sync = pb[0];
  }
  if(sync != null) sync.TryRun(arg);
}
[/code]
Просто скопируйте этот код С# в поле "Код" программного блока, который будет вместо таймера, и измените настройки на свои.

-------------------------------------------------------------------------------------------------------------------------------------------
Отладка сценариев
-------------------------------------------------------------------------------------------------------------------------------------------
Для включения режима отладки @-блоков нужно установить значение переменной [b][i]debug[/i][/b] в коде скрипта Easy Play равным [b]true[/b]. По умолчанию  ход выполнения сценария выводится на экран программного блока. 

Вы можете использовать для вывода любой экран (поверхность) для чего в переменной [b][i]conLCD[/i][/b] нужно указать имя блока с которого оно начинается и номер экрана (если требуется). Например, "Cockpit[1]" выведет диагностику на центральный экран промышленного кокпита.

Вывод команд осуществляется построчно с указанием имени @-блока и полного имени команды или свойства, которое было задействовано. Если в выражении участвует переменная, то ее имя с лидирующим обратным слэшем "\" будет выведено вслед за командой. Количество блоков, попавших в выборку, указывается в круглых скобках "()". Для команд [b][i]Delay[/i][/b] и [b][i]When[/i][/b] указывается время выполнения в секундах. 
[quote][previewimg=25698620;sizeFull,inline;ep_04.jpg][/previewimg][/quote]
Отслеживание логики выполнения можно осуществлять по набору команд, которые были выполнены для внутри ветки [i]If / Else[/i]. Команды, которые были выполнены, выводятся на консоль сразу после ключевого слова, а условия, которые были проигнорированы, выводятся одной строкой, содержащей только ключевое слово [i]If/Else If/Else[/i] без показа команд, которые должны были быть выполнены.

Рекомпиляция кода производится всякий раз, когда вы изменяете поле "Свои данные" ПБ Easy Play. Время, затраченное на компиляцию выводится первой строкой в консоли. Дополнительно, в []-скобках выводится количество выполненных инструкций.
[quote]
По умолчанию в SE допускается одновременное выполнение не более 50000 инструкций, при превышении это значения выдается системная ошибка "[u]Скрипт слишком сложный...[/u]". Это призвано защитить игру от бесконечных циклов внутри кода, но т.к. EasyPlay представляет собой интерпретатор поля CustomData, то слишком длинный код в нем может вызвать эту ошибки на этапе компиляции.
[/quote]
Для отладки так же можно использовать команды [b][i]Echo[/i][/b] и [b][i]Console[/i][/b] с помощью которых можно просматривать промежуточные значения переменных в области Echo панели управления или прямо в консоли. Последнее бывает полезно для копирования результатов в буфер обмена, т.к. консольный вывод на экран доступен для редактирования через кнопку "[u]Редактировать[/u]" для любой панели если установлен режим "[u]текст и изображение[/u]":
[code]
@test {
Console = "GPS:MyPos:{Grid Position of MyShip}:#"
}
[/code]
В примере выше осуществляется вывод на консоль текущих координат корабля в формате GPS. После выполнения в поле "[u]Большой дисплей[/u]" ПБ Easy Play по кнопке "[u]Редактировать[/u]" будет доступно что-то типа [i]GPS:MyPos:-261248.412871745:-2350813.49051253:352906.455766861:#[/i]. Эту строку можно прямо скопировать из буфера обмена в системной панели "GPS" чтобы получить метку с текущими координатами, так как если бы вы задействовали там кнопку "[u]Новая из текущей позиции[/u]".

[h2]Обработка ошибок[/h2]
Ошибки бывают 2-х типов: критические (код ошибки больше 400) и некритические (код ошибки больше 300 и меньше 400). 

Критические ошибки в основном возникают на этапе компиляции и блокируют выполнение сценария. На консоль в этом случае выводится только сообщение об ошибке, например, "[u]E402> Дисбаланс {}[/u]". Локализовать такую ошибку не представляется возможным, поэтому искать ее в коде следует там, где были произведены последние изменения.

При возникновении некритичной ошибки ее код выводится напротив команды, которая содержит ошибку, но выполнение сценария не прерывается. Типичный пример такого сценария — отстрел ракет путем обращения к программному блоку управления ракетой. Если ракеты кончились, то очередное обращение вызовет ошибку с кодом 313, говорящую что блок с таким именем не найден и это никак не отразится на игровом процессе.

Вывод ошибок производится на языке локализации, если соответствующие данные установлены в поле "[u]Клавиатура[/u]" ПБ Easy Play.

[h2]Системная ошибка[/h2]
Возникает в случае внутренней ошибки Easy Play и делает неработоспособным программный блок. В случае ее возникновения в области Echo появляется системное сообщение компилятора C#  и для продолжения работы всей автоматизации необходимо заново скомпилировать скрипт.
[quote][previewimg=25817537;sizeFull,inline;ep_07.jpg][/previewimg][/quote]
По сравнению с оригинальным скриптом, Easy Play более устойчив к системным ошибкам, но полностью исключить их не удастся, так как приходится обрабатывать пользовательские переменные, которые не всегда соответствуют нужному формату.

-------------------------------------------------------------------------------------------------------------------------------------------
Локализация Easy Play
-------------------------------------------------------------------------------------------------------------------------------------------
Локализация, т.е. перевод на язык, отличный от оригинального английского, реализована на уровне вывода системных сообщений, ошибок выполнения сценариев и названий игровых компонентов — руд, слитков, расходных материалов и т.п.

Установка локализации производится путем размещения в поле "[u]Редактировать[/u]" [b]клавиатуры[/b] программного блока Easy Play двух ini-блоков:
[code]
[b][sys][/b]
100 = ru
101 = Свойство 
102 = Действие 
...
[b][lng][/b]
Cobalt = Кобальт
Gold = Золото
Ice = Лед
[/code]
Блок [b][sys][/b] отвечает за вывод на консоль системных сообщений и ошибок. Он должен начинаться с указания префикса языка [i]100 = префикс[/i], который указывается в коде скрипта Easy Play в перемененной [i]language[/i]. При смене языка скрипт следует рекомпилировать.

Блок [b][lng][/b] отвечает за вывод команд [b][i]Inventory[/i][/b] и [b][i]Status[/i][/b]. Это перевод  внутри игровых названий большинства компонентов. Если этот блок отсутствует, то вывод осуществляется на английском.
[quote][previewimg=25818337;sizeFull,inline;ep_10.jpg][/previewimg][/quote]

[i]Замечание:[/i] в настоящий момент есть только русская локализация, переводы на другие языки будут публиковаться в Steam Workshop  в обсуждениях к скрипту по мере возможности.

-------------------------------------------------------------------------------------------------------------------------------------------
Известные проблемы
-------------------------------------------------------------------------------------------------------------------------------------------
1. Нельзя вывести "{" или "}" (одиночную фигурную скобку) в командах [b][i]Write[/i][/b] и [b][i]Data[/i][/b] — это будет приводить к ошибке баланса скобок при компиляции автоматизации.

2. В именах блоков не следует использовать ключевые слова [b]if[/b], [b]else[/b], [b]when[/b], [b]of[/b], [b]at[/b], [b]to[/b], [b]on[/b], [b]MyShip[/b], [b]MyGrid[/b], [b]AllGrid[/b] — это может приводить к неправильной работе сценария. Например команда [i]Start[/i] для блока с именем "[u]Timer of Alert[/u]" просто не будет выполнена из-за наличия в имени блока ключевого слова [b]of[/b], а логика [b][i]if/else[/i][/b] выдаст некритичную ошибку выполнения:
[code]
* этот сценарий работать не будет
if OnOff Timer of Alert = True {
  Start Timer of Alert
}
[/code]

3. Запись на кнопочную панель без экрана вызывает крах скрипта, поскольку Sci-Fi панель и обычная панель не отличаются по свойствам
